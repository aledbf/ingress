{
  "modules": [
    {
      "name": "ngx_http_core_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_core_module.html",
      "directives": [
        {
          "name": "absolute_redirect",
          "syntax": "absolute_redirect on | off;",
          "default": "absolute_redirect on;",
          "context": "http, server, location",
          "description": "\nIf disabled, redirects issued by nginx will be relative.\n\n\nSee also server_name_in_redirect\nand port_in_redirect directives.\n"
        },
        {
          "name": "aio",
          "syntax": "aio on | off | threads[=pool];",
          "default": "aio off;",
          "context": "http, server, location",
          "description": "\nEnables or disables the use of asynchronous file I/O (AIO)\non FreeBSD and Linux:\n\nlocation /video/ {\n    aio            on;\n    output_buffers 1 64k;\n}\n\n \n\n\nOn FreeBSD, AIO can be used starting from FreeBSD 4.3.\nPrior to FreeBSD 11.0,\nAIO can either be linked statically into a kernel:\n\noptions VFS_AIO\n\n \nor loaded dynamically as a kernel loadable module:\n\nkldload aio\n\n \n\n\nOn Linux, AIO can be used starting from kernel version 2.6.22.\nAlso, it is necessary to enable\ndirectio,\nor otherwise reading will be blocking:\n\nlocation /video/ {\n    aio            on;\n    directio       512;\n    output_buffers 1 128k;\n}\n\n \n\n\nOn Linux,\ndirectio\ncan only be used for reading blocks that are aligned on 512-byte\nboundaries (or 4K for XFS).\nFile’s unaligned end is read in blocking mode.\nThe same holds true for byte range requests and for FLV requests\nnot from the beginning of a file: reading of unaligned data at the\nbeginning and end of a file will be blocking.\n\n\nWhen both AIO and sendfile are enabled on Linux,\nAIO is used for files that are larger than or equal to\nthe size specified in the directio directive,\nwhile sendfile is used for files of smaller sizes\nor when directio is disabled.\n\nlocation /video/ {\n    sendfile       on;\n    aio            on;\n    directio       8m;\n}\n\n \n\n\nFinally, files can be read and sent\nusing multi-threading (1.7.11),\nwithout blocking a worker process:\n\nlocation /video/ {\n    sendfile       on;\n    aio            threads;\n}\n\n \nRead and send file operations are offloaded to threads of the specified\npool.\nIf the pool name is omitted,\nthe pool with the name “default” is used.\nThe pool name can also be set with variables:\n\naio threads=pool$disk;\n\n \nBy default, multi-threading is disabled, it should be\nenabled with the\n--with-threads configuration parameter.\nCurrently, multi-threading is compatible only with the\nepoll,\nkqueue,\nand\neventport methods.\nMulti-threaded sending of files is only supported on Linux.\n\n\nSee also the sendfile directive.\n"
        },
        {
          "name": "aio_write",
          "syntax": "aio_write on | off;",
          "default": "aio_write off;",
          "context": "http, server, location",
          "description": "\nIf aio is enabled, specifies whether it is used for writing files.\nCurrently, this only works when using\naio threads\nand is limited to writing temporary files\nwith data received from proxied servers.\n"
        },
        {
          "name": "alias",
          "syntax": "alias path;",
          "context": "location",
          "description": "\nDefines a replacement for the specified location.\nFor example, with the following configuration\n\nlocation /i/ {\n    alias /data/w3/images/;\n}\n\n \non request of\n“/i/top.gif”, the file\n/data/w3/images/top.gif will be sent.\n\n\nThe path value can contain variables,\nexcept $document_root and $realpath_root.\n\n\nIf alias is used inside a location defined\nwith a regular expression then such regular expression should\ncontain captures and alias should refer to\nthese captures (0.7.40), for example:\n\nlocation ~ ^/users/(.+\\.(?:gif|jpe?g|png))$ {\n    alias /data/w3/images/$1;\n}\n\n \n\n\nWhen location matches the last part of the directive’s value:\n\nlocation /images/ {\n    alias /data/w3/images/;\n}\n\n \nit is better to use the\nroot\ndirective instead:\n\nlocation /images/ {\n    root /data/w3;\n}\n\n \n"
        },
        {
          "name": "chunked_transfer_encoding",
          "syntax": "chunked_transfer_encoding on | off;",
          "default": "chunked_transfer_encoding on;",
          "context": "http, server, location",
          "description": "\nAllows disabling chunked transfer encoding in HTTP/1.1.\nIt may come in handy when using a software failing to support\nchunked encoding despite the standard’s requirement.\n"
        },
        {
          "name": "client_body_buffer_size",
          "syntax": "client_body_buffer_size size;",
          "default": "client_body_buffer_size 8k|16k;",
          "context": "http, server, location",
          "description": "\nSets buffer size for reading client request body.\nIn case the request body is larger than the buffer,\nthe whole body or only its part is written to a\ntemporary file.\nBy default, buffer size is equal to two memory pages.\nThis is 8K on x86, other 32-bit platforms, and x86-64.\nIt is usually 16K on other 64-bit platforms.\n"
        },
        {
          "name": "client_body_in_file_only",
          "syntax": "client_body_in_file_only on | clean | off;",
          "default": "client_body_in_file_only off;",
          "context": "http, server, location",
          "description": "\nDetermines whether nginx should save the entire client request body\ninto a file.\nThis directive can be used during debugging, or when using the\n$request_body_file\nvariable, or the\n$r->request_body_file\nmethod of the module\nngx_http_perl_module.\n\n\nWhen set to the value on, temporary files are not\nremoved after request processing.\n\n\nThe value clean will cause the temporary files\nleft after request processing to be removed.\n"
        },
        {
          "name": "client_body_in_single_buffer",
          "syntax": "client_body_in_single_buffer on | off;",
          "default": "client_body_in_single_buffer off;",
          "context": "http, server, location",
          "description": "\nDetermines whether nginx should save the entire client request body\nin a single buffer.\nThe directive is recommended when using the\n$request_body\nvariable, to save the number of copy operations involved.\n"
        },
        {
          "name": "client_body_temp_path",
          "syntax": "client_body_temp_path path [level1 [level2 [level3]]];",
          "default": "client_body_temp_path client_body_temp;",
          "context": "http, server, location",
          "description": "\nDefines a directory for storing temporary files holding client request bodies.\nUp to three-level subdirectory hierarchy can be used under the specified\ndirectory.\nFor example, in the following configuration\n\nclient_body_temp_path /spool/nginx/client_temp 1 2;\n\n \na path to a temporary file might look like this:\n\n/spool/nginx/client_temp/7/45/00000123457\n\n \n"
        },
        {
          "name": "client_body_timeout",
          "syntax": "client_body_timeout time;",
          "default": "client_body_timeout 60s;",
          "context": "http, server, location",
          "description": "\nDefines a timeout for reading client request body.\nThe timeout is set only for a period between two successive read operations,\nnot for the transmission of the whole request body.\nIf a client does not transmit anything within this time, the\nrequest is terminated with the\n408 (Request Time-out)\nerror.\n"
        },
        {
          "name": "client_header_buffer_size",
          "syntax": "client_header_buffer_size size;",
          "default": "client_header_buffer_size 1k;",
          "context": "http, server",
          "description": "\nSets buffer size for reading client request header.\nFor most requests, a buffer of 1K bytes is enough.\nHowever, if a request includes long cookies, or comes from a WAP client,\nit may not fit into 1K.\nIf a request line or a request header field does not fit into\nthis buffer then larger buffers, configured by the\nlarge_client_header_buffers directive,\nare allocated.\n"
        },
        {
          "name": "client_header_timeout",
          "syntax": "client_header_timeout time;",
          "default": "client_header_timeout 60s;",
          "context": "http, server",
          "description": "\nDefines a timeout for reading client request header.\nIf a client does not transmit the entire header within this time, the\nrequest is terminated with the\n408 (Request Time-out)\nerror.\n"
        },
        {
          "name": "client_max_body_size",
          "syntax": "client_max_body_size size;",
          "default": "client_max_body_size 1m;",
          "context": "http, server, location",
          "description": "\nSets the maximum allowed size of the client request body,\nspecified in the\n“Content-Length”\nrequest header field.\nIf the size in a request exceeds the configured value, the\n413 (Request Entity Too Large)\nerror is returned to the client.\nPlease be aware that\nbrowsers cannot correctly display\nthis error.\nSetting size to 0 disables checking of client\nrequest body size.\n"
        },
        {
          "name": "connection_pool_size",
          "syntax": "connection_pool_size size;",
          "default": "connection_pool_size 256|512;",
          "context": "http, server",
          "description": "\nAllows accurate tuning of per-connection memory allocations.\nThis directive has minimal impact on performance\nand should not generally be used.\nBy default, the size is equal to\n256 bytes on 32-bit platforms and 512 bytes on 64-bit platforms.\n\n\nPrior to version 1.9.8, the default value was 256 on all platforms.\n\n \n"
        },
        {
          "name": "default_type",
          "syntax": "default_type mime-type;",
          "default": "default_type text/plain;",
          "context": "http, server, location",
          "description": "\nDefines the default MIME type of a response.\nMapping of file name extensions to MIME types can be set\nwith the types directive.\n"
        },
        {
          "name": "directio",
          "syntax": "directio size | off;",
          "default": "directio off;",
          "context": "http, server, location",
          "description": "\nEnables the use of\nthe O_DIRECT flag (FreeBSD, Linux),\nthe F_NOCACHE flag (macOS),\nor the directio() function (Solaris),\nwhen reading files that are larger than or equal to\nthe specified size.\nThe directive automatically disables (0.7.15) the use of\nsendfile\nfor a given request.\nIt can be useful for serving large files:\n\ndirectio 4m;\n\n \nor when using aio on Linux.\n"
        },
        {
          "name": "directio_alignment",
          "syntax": "directio_alignment size;",
          "default": "directio_alignment 512;",
          "context": "http, server, location",
          "description": "\nSets the alignment for\ndirectio.\nIn most cases, a 512-byte alignment is enough.\nHowever, when using XFS under Linux, it needs to be increased to 4K.\n"
        },
        {
          "name": "disable_symlinks",
          "syntax": "disable_symlinks off;disable_symlinks on | if_not_owner [from=part];",
          "default": "disable_symlinks off;",
          "context": "http, server, location",
          "description": "\nDetermines how symbolic links should be treated when opening files:\n\n\n\noff\n\nSymbolic links in the pathname are allowed and not checked.\nThis is the default behavior.\n\n\non\n\nIf any component of the pathname is a symbolic link,\naccess to a file is denied.\n\n\nif_not_owner\n\nAccess to a file is denied if any component of the pathname\nis a symbolic link, and the link and object that the link\npoints to have different owners.\n\n\nfrom=part\n\nWhen checking symbolic links\n(parameters on and if_not_owner),\nall components of the pathname are normally checked.\nChecking of symbolic links in the initial part of the pathname\nmay be avoided by specifying additionally the\nfrom=part parameter.\nIn this case, symbolic links are checked only from\nthe pathname component that follows the specified initial part.\nIf the value is not an initial part of the pathname checked, the whole\npathname is checked as if this parameter was not specified at all.\nIf the value matches the whole file name,\nsymbolic links are not checked.\nThe parameter value can contain variables.\n\n\n\n \n\n\nExample:\n\ndisable_symlinks on from=$document_root;\n\n \n\n\nThis directive is only available on systems that have the\nopenat() and fstatat() interfaces.\nSuch systems include modern versions of FreeBSD, Linux, and Solaris.\n\n\nParameters on and if_not_owner\nadd a processing overhead.\n\n\nOn systems that do not support opening of directories only for search,\nto use these parameters it is required that worker processes\nhave read permissions for all directories being checked.\n\n \n\n\n\n\nThe\nngx_http_autoindex_module,\nngx_http_random_index_module,\nand ngx_http_dav_module\nmodules currently ignore this directive.\n\n \n"
        },
        {
          "name": "error_page",
          "syntax": "error_page code ... [=[response]] uri;",
          "context": "http, server, location, if in location",
          "description": "\nDefines the URI that will be shown for the specified errors.\nA uri value can contain variables.\n\n\nExample:\n\nerror_page 404             /404.html;\nerror_page 500 502 503 504 /50x.html;\n\n \n\n\nThis causes an internal redirect to the specified uri\nwith the client request method changed to “GET”\n(for all methods other than\n“GET” and “HEAD”).\n\n\nFurthermore, it is possible to change the response code to another\nusing the “=response” syntax, for example:\n\nerror_page 404 =200 /empty.gif;\n\n \n\n\nIf an error response is processed by a proxied server\nor a FastCGI/uwsgi/SCGI/gRPC server,\nand the server may return different response codes (e.g., 200, 302, 401\nor 404), it is possible to respond with the code it returns:\n\nerror_page 404 = /404.php;\n\n \n\n\nIf there is no need to change URI and method during internal redirection\nit is possible to pass error processing into a named location:\n\nlocation / {\n    error_page 404 = @fallback;\n}\n\nlocation @fallback {\n    proxy_pass http://backend;\n}\n\n \n\n\n\n\nIf uri processing leads to an error,\nthe status code of the last occurred error is returned to the client.\n\n \n\n\nIt is also possible to use URL redirects for error processing:\n\nerror_page 403      http://example.com/forbidden.html;\nerror_page 404 =301 http://example.com/notfound.html;\n\n \nIn this case, by default, the response code 302 is returned to the client.\nIt can only be changed to one of the redirect status\ncodes (301, 302, 303, 307, and 308).\n\n\nThe code 307 was not treated as a redirect until versions 1.1.16 and 1.0.13.\n\n \n\n\n\nThe code 308 was not treated as a redirect until version 1.13.0.\n\n \n\n\nThese directives are inherited from the previous level if and\nonly if there are no\nerror_page\ndirectives defined on the current level.\n"
        },
        {
          "name": "etag",
          "syntax": "etag on | off;",
          "default": "etag on;",
          "context": "http, server, location",
          "description": "\nEnables or disables automatic generation of the “ETag”\nresponse header field for static resources.\n"
        },
        {
          "name": "http",
          "syntax": "http { ... }",
          "context": "main",
          "description": "\nProvides the configuration file context in which the HTTP server directives\nare specified.\n"
        },
        {
          "name": "if_modified_since",
          "syntax": "if_modified_since off | exact | before;",
          "default": "if_modified_since exact;",
          "context": "http, server, location",
          "description": "\nSpecifies how to compare modification time of a response\nwith the time in the\n“If-Modified-Since”\nrequest header field:\n\n\n\n\noff\n\nthe\n“If-Modified-Since” request header field is ignored (0.7.34);\n\n\nexact\n\nexact match;\n\n\nbefore\n\nmodification time of a response is\nless than or equal to the time in the “If-Modified-Since”\nrequest header field.\n\n\n\n \n"
        },
        {
          "name": "ignore_invalid_headers",
          "syntax": "ignore_invalid_headers on | off;",
          "default": "ignore_invalid_headers on;",
          "context": "http, server",
          "description": "\nControls whether header fields with invalid names should be ignored.\nValid names are composed of English letters, digits, hyphens, and possibly\nunderscores (as controlled by the underscores_in_headers\ndirective).\n\n\nIf the directive is specified on the server level,\nits value is only used if a server is a default one.\nThe value specified also applies to all virtual servers\nlistening on the same address and port.\n"
        },
        {
          "name": "internal;",
          "syntax": "internal;",
          "context": "location",
          "description": "\nSpecifies that a given location can only be used for internal requests.\nFor external requests, the client error\n404 (Not Found)\nis returned.\nInternal requests are the following:\n\n\n\n\n\nrequests redirected by the\nerror_page,\nindex,\nrandom_index, and\ntry_files directives;\n\n\n\nrequests redirected by the “X-Accel-Redirect”\nresponse header field from an upstream server;\n\n\n\nsubrequests formed by the\n“include virtual”\ncommand of the\nngx_http_ssi_module\nmodule, by the\nngx_http_addition_module\nmodule directives, and by\nauth_request and\nmirror directives;\n\n\n\nrequests changed by the\nrewrite directive.\n\n\n\n \n\n\nExample:\n\nerror_page 404 /404.html;\n\nlocation = /404.html {\n    internal;\n}\n\n \n\n\nThere is a limit of 10 internal redirects per request to prevent\nrequest processing cycles that can occur in incorrect configurations.\nIf this limit is reached, the error\n500 (Internal Server Error) is returned.\nIn such cases, the “rewrite or internal redirection cycle” message\ncan be seen in the error log.\n\n \n"
        },
        {
          "name": "keepalive_disable",
          "syntax": "keepalive_disable none | browser ...;",
          "default": "keepalive_disable msie6;",
          "context": "http, server, location",
          "description": "\nDisables keep-alive connections with misbehaving browsers.\nThe browser parameters specify which\nbrowsers will be affected.\nThe value msie6 disables keep-alive connections\nwith old versions of MSIE, once a POST request is received.\nThe value safari disables keep-alive connections\nwith Safari and Safari-like browsers on macOS and macOS-like\noperating systems.\nThe value none enables keep-alive connections\nwith all browsers.\n\n\nPrior to version 1.1.18, the value safari matched\nall Safari and Safari-like browsers on all operating systems, and\nkeep-alive connections with them were disabled by default.\n\n \n"
        },
        {
          "name": "keepalive_requests",
          "syntax": "keepalive_requests number;",
          "default": "keepalive_requests 100;",
          "context": "http, server, location",
          "description": "\nSets the maximum number of requests that can be\nserved through one keep-alive connection.\nAfter the maximum number of requests are made, the connection is closed.\n"
        },
        {
          "name": "keepalive_timeout",
          "syntax": "keepalive_timeout timeout [header_timeout];",
          "default": "keepalive_timeout 75s;",
          "context": "http, server, location",
          "description": "\nThe first parameter sets a timeout during which a keep-alive\nclient connection will stay open on the server side.\nThe zero value disables keep-alive client connections.\nThe optional second parameter sets a value in the\n“Keep-Alive: timeout=time”\nresponse header field.\nTwo parameters may differ.\n\n\nThe\n“Keep-Alive: timeout=time”\nheader field is recognized by Mozilla and Konqueror.\nMSIE closes keep-alive connections by itself in about 60 seconds.\n"
        },
        {
          "name": "large_client_header_buffers",
          "syntax": "large_client_header_buffers number size;",
          "default": "large_client_header_buffers 4 8k;",
          "context": "http, server",
          "description": "\nSets the maximum number and size of\nbuffers used for reading large client request header.\nA request line cannot exceed the size of one buffer, or the\n414 (Request-URI Too Large)\nerror is returned to the client.\nA request header field cannot exceed the size of one buffer as well, or the\n400 (Bad Request)\nerror is returned to the client.\nBuffers are allocated only on demand.\nBy default, the buffer size is equal to 8K bytes.\nIf after the end of request processing a connection is transitioned\ninto the keep-alive state, these buffers are released.\n"
        },
        {
          "name": "limit_except",
          "syntax": "limit_except method ... { ... }",
          "context": "location",
          "description": "\nLimits allowed HTTP methods inside a location.\nThe method parameter can be one of the following:\nGET,\nHEAD,\nPOST,\nPUT,\nDELETE,\nMKCOL,\nCOPY,\nMOVE,\nOPTIONS,\nPROPFIND,\nPROPPATCH,\nLOCK,\nUNLOCK,\nor\nPATCH.\nAllowing the GET method makes the\nHEAD method also allowed.\nAccess to other methods can be limited using the\nngx_http_access_module,\nngx_http_auth_basic_module,\nand\nngx_http_auth_jwt_module\n(1.13.10)\nmodules directives:\n\nlimit_except GET {\n    allow 192.168.1.0/32;\n    deny  all;\n}\n\n \nPlease note that this will limit access to all methods\nexcept GET and HEAD.\n"
        },
        {
          "name": "limit_rate",
          "syntax": "limit_rate rate;",
          "default": "limit_rate 0;",
          "context": "http, server, location, if in location",
          "description": "\nLimits the rate of response transmission to a client.\nThe rate is specified in bytes per second.\nThe zero value disables rate limiting.\n\nThe limit is set per a request, and so if a client simultaneously opens\ntwo connections, the overall rate will be twice as much\nas the specified limit.\n\n\nParameter value can contain variables (1.17.0).\nIt may be useful in cases where rate should be limited\ndepending on a certain condition:\n\nmap $slow $rate {\n    1     4k;\n    2     8k;\n}\n\nlimit_rate $rate;\n\n \n\n\nRate limit can also be set in the\n$limit_rate variable,\nhowever, since version 1.17.0, this method is not recommended:\n\nserver {\n\n    if ($slow) {\n        set $limit_rate 4k;\n    }\n\n    ...\n}\n\n \n\n\nRate limit can also be set in the\n“X-Accel-Limit-Rate” header field of a proxied server response.\nThis capability can be disabled using the\nproxy_ignore_headers,\nfastcgi_ignore_headers,\nuwsgi_ignore_headers,\nand\nscgi_ignore_headers\ndirectives.\n"
        },
        {
          "name": "limit_rate_after",
          "syntax": "limit_rate_after size;",
          "default": "limit_rate_after 0;",
          "context": "http, server, location, if in location",
          "description": "\nSets the initial amount after which the further transmission\nof a response to a client will be rate limited.\nParameter value can contain variables (1.17.0).\n\n\nExample:\n\nlocation /flv/ {\n    flv;\n    limit_rate_after 500k;\n    limit_rate       50k;\n}\n\n \n"
        },
        {
          "name": "lingering_close",
          "syntax": "lingering_close off | on | always;",
          "default": "lingering_close on;",
          "context": "http, server, location",
          "description": "\nControls how nginx closes client connections.\n\n\nThe default value “on” instructs nginx to\nwait for and\nprocess additional data from a client\nbefore fully closing a connection, but only\nif heuristics suggests that a client may be sending more data.\n\n\nThe value “always” will cause nginx to unconditionally\nwait for and process additional client data.\n\n\nThe value “off” tells nginx to never wait for\nmore data and close the connection immediately.\nThis behavior breaks the protocol and should not be used under normal\ncircumstances.\n"
        },
        {
          "name": "lingering_time",
          "syntax": "lingering_time time;",
          "default": "lingering_time 30s;",
          "context": "http, server, location",
          "description": "\nWhen lingering_close is in effect,\nthis directive specifies the maximum time during which nginx\nwill process (read and ignore) additional data coming from a client.\nAfter that, the connection will be closed, even if there will be\nmore data.\n"
        },
        {
          "name": "lingering_timeout",
          "syntax": "lingering_timeout time;",
          "default": "lingering_timeout 5s;",
          "context": "http, server, location",
          "description": "\nWhen lingering_close is in effect, this directive specifies\nthe maximum waiting time for more client data to arrive.\nIf data are not received during this time, the connection is closed.\nOtherwise, the data are read and ignored, and nginx starts waiting\nfor more data again.\nThe “wait-read-ignore” cycle is repeated, but no longer than specified by the\nlingering_time directive.\n"
        },
        {
          "name": "listen",
          "syntax": "listen address[:port] [default_server] [ssl] [http2 | spdy] [proxy_protocol] [setfib=number] [fastopen=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [bind] [ipv6only=on|off] [reuseport] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];listen port [default_server] [ssl] [http2 | spdy] [proxy_protocol] [setfib=number] [fastopen=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [bind] [ipv6only=on|off] [reuseport] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];listen unix:path [default_server] [ssl] [http2 | spdy] [proxy_protocol] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [bind] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];",
          "default": "listen *:80 | *:8000;",
          "context": "server",
          "description": "\nSets the address and port for IP,\nor the path for a UNIX-domain socket on which\nthe server will accept requests.\nBoth address and port,\nor only address or only port can be specified.\nAn address may also be a hostname, for example:\n\nlisten 127.0.0.1:8000;\nlisten 127.0.0.1;\nlisten 8000;\nlisten *:8000;\nlisten localhost:8000;\n\n \nIPv6 addresses (0.7.36) are specified in square brackets:\n\nlisten [::]:8000;\nlisten [::1];\n\n \nUNIX-domain sockets (0.8.21) are specified with the “unix:”\nprefix:\n\nlisten unix:/var/run/nginx.sock;\n\n \n\n\nIf only address is given, the port 80 is used.\n\n\nIf the directive is not present then either *:80 is used\nif nginx runs with the superuser privileges, or *:8000\notherwise.\n\n\nThe default_server parameter, if present,\nwill cause the server to become the default server for the specified\naddress:port pair.\nIf none of the directives have the default_server\nparameter then the first server with the\naddress:port pair will be\nthe default server for this pair.\n\n\nIn versions prior to 0.8.21 this parameter is named simply\ndefault.\n\n \n\n\nThe ssl parameter (0.7.14) allows specifying that all\nconnections accepted on this port should work in SSL mode.\nThis allows for a more compact configuration for the server that\nhandles both HTTP and HTTPS requests.\n\n\nThe http2 parameter (1.9.5) configures the port to accept\nHTTP/2 connections.\nNormally, for this to work the ssl parameter should be\nspecified as well, but nginx can also be configured to accept HTTP/2\nconnections without SSL.\n\n\nThe spdy parameter (1.3.15-1.9.4) allows accepting\nSPDY connections on this port.\nNormally, for this to work the ssl parameter should be\nspecified as well, but nginx can also be configured to accept SPDY\nconnections without SSL.\n\n\nThe proxy_protocol parameter (1.5.12)\nallows specifying that all connections accepted on this port should use the\nPROXY\nprotocol.\n\n\nThe PROXY protocol version 2 is supported since version 1.13.11.\n\n \n\n\nThe listen directive\ncan have several additional parameters specific to socket-related system calls.\nThese parameters can be specified in any\nlisten directive, but only once for a given\naddress:port pair.\n\n\nIn versions prior to 0.8.21, they could only be\nspecified in the listen directive together with the\ndefault parameter.\n\n \n\n\n\n\nsetfib=number\n\n\nthis parameter (0.8.44) sets the associated routing table, FIB\n(the SO_SETFIB option) for the listening socket.\nThis currently works only on FreeBSD.\n\n\n\nfastopen=number\n\n\nenables\n“TCP Fast Open”\nfor the listening socket (1.5.8) and\nlimits\nthe maximum length for the queue of connections that have not yet completed\nthe three-way handshake.\n\nDo not enable this feature unless the server can handle\nreceiving the\n\nsame SYN packet with data more than once.\n\n\n\n\nbacklog=number\n\n\nsets the backlog parameter in the\nlisten() call that limits\nthe maximum length for the queue of pending connections.\nBy default,\nbacklog is set to -1 on FreeBSD, DragonFly BSD, and macOS,\nand to 511 on other platforms.\n\n\n\nrcvbuf=size\n\n\nsets the receive buffer size\n(the SO_RCVBUF option) for the listening socket.\n\n\n\nsndbuf=size\n\n\nsets the send buffer size\n(the SO_SNDBUF option) for the listening socket.\n\n\n\naccept_filter=filter\n\n\nsets the name of accept filter\n(the SO_ACCEPTFILTER option) for the listening socket\nthat filters incoming connections before passing them to\naccept().\nThis works only on FreeBSD and NetBSD 5.0+.\nPossible values are\ndataready\nand\nhttpready.\n\n\n\ndeferred\n\n\ninstructs to use a deferred accept()\n(the TCP_DEFER_ACCEPT socket option) on Linux.\n\n\n\nbind\n\n\ninstructs to make a separate bind() call for a given\naddress:port pair.\nThis is useful because if there are several listen\ndirectives with the same port but different addresses, and one of the\nlisten directives listens on all addresses\nfor the given port (*:port), nginx\nwill bind() only to *:port.\nIt should be noted that the getsockname() system call will be\nmade in this case to determine the address that accepted the connection.\nIf the setfib,\nbacklog, rcvbuf,\nsndbuf, accept_filter,\ndeferred, ipv6only,\nor so_keepalive parameters\nare used then for a given\naddress:port pair\na separate bind() call will always be made.\n\n\n\nipv6only=on|off\n\n\nthis parameter (0.7.42) determines\n(via the IPV6_V6ONLY socket option)\nwhether an IPv6 socket listening on a wildcard address [::]\nwill accept only IPv6 connections or both IPv6 and IPv4 connections.\nThis parameter is turned on by default.\nIt can only be set once on start.\n\nPrior to version 1.3.4,\nif this parameter was omitted then the operating system’s settings were\nin effect for the socket.\n\n\n\n\nreuseport\n\n\nthis parameter (1.9.1) instructs to create an individual listening socket\nfor each worker process\n(using the\nSO_REUSEPORT socket option on Linux 3.9+ and DragonFly BSD,\nor SO_REUSEPORT_LB on FreeBSD 12+), allowing a kernel\nto distribute incoming connections between worker processes.\nThis currently works only on Linux 3.9+, DragonFly BSD,\nand FreeBSD 12+ (1.15.1).\n\nInappropriate use of this option may have its security\nimplications.\n\n\n\n\nso_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]\n\n\nthis parameter (1.1.11) configures the “TCP keepalive” behavior\nfor the listening socket.\nIf this parameter is omitted then the operating system’s settings will be\nin effect for the socket.\nIf it is set to the value “on”, the\nSO_KEEPALIVE option is turned on for the socket.\nIf it is set to the value “off”, the\nSO_KEEPALIVE option is turned off for the socket.\nSome operating systems support setting of TCP keepalive parameters on\na per-socket basis using the TCP_KEEPIDLE,\nTCP_KEEPINTVL, and TCP_KEEPCNT socket options.\nOn such systems (currently, Linux 2.4+, NetBSD 5+, and\nFreeBSD 9.0-STABLE), they can be configured\nusing the keepidle, keepintvl, and\nkeepcnt parameters.\nOne or two parameters may be omitted, in which case the system default setting\nfor the corresponding socket option will be in effect.\nFor example,\nso_keepalive=30m::10\nwill set the idle timeout (TCP_KEEPIDLE) to 30 minutes,\nleave the probe interval (TCP_KEEPINTVL) at its system default,\nand set the probes count (TCP_KEEPCNT) to 10 probes.\n\n\n\n \n\n\nExample:\n\nlisten 127.0.0.1 default_server accept_filter=dataready backlog=1024;\n\n \n"
        },
        {
          "name": "location",
          "syntax": "location [ = | ~ | ~* | ^~ ] uri { ... }location @name { ... }",
          "context": "server, location",
          "description": "\nSets configuration depending on a request URI.\n\n\nThe matching is performed against a normalized URI,\nafter decoding the text encoded in the “%XX” form,\nresolving references to relative path components “.”\nand “..”, and possible\ncompression of two or more\nadjacent slashes into a single slash.\n\n\nA location can either be defined by a prefix string, or by a regular expression.\nRegular expressions are specified with the preceding\n“~*” modifier (for case-insensitive matching), or the\n“~” modifier (for case-sensitive matching).\nTo find location matching a given request, nginx first checks\nlocations defined using the prefix strings (prefix locations).\nAmong them, the location with the longest matching\nprefix is selected and remembered.\nThen regular expressions are checked, in the order of their appearance\nin the configuration file.\nThe search of regular expressions terminates on the first match,\nand the corresponding configuration is used.\nIf no match with a regular expression is found then the\nconfiguration of the prefix location remembered earlier is used.\n\n\nlocation blocks can be nested, with some exceptions\nmentioned below.\n\n\nFor case-insensitive operating systems such as macOS and Cygwin,\nmatching with prefix strings ignores a case (0.7.7).\nHowever, comparison is limited to one-byte locales.\n\n\nRegular expressions can contain captures (0.7.40) that can later\nbe used in other directives.\n\n\nIf the longest matching prefix location has the “^~” modifier\nthen regular expressions are not checked.\n\n\nAlso, using the “=” modifier it is possible to define\nan exact match of URI and location.\nIf an exact match is found, the search terminates.\nFor example, if a “/” request happens frequently,\ndefining “location = /” will speed up the processing\nof these requests, as search terminates right after the first\ncomparison.\nSuch a location cannot obviously contain nested locations.\n\n\n\n\nIn versions from 0.7.1 to 0.8.41, if a request matched the prefix\nlocation without the “=” and “^~”\nmodifiers, the search also terminated and regular expressions were\nnot checked.\n\n \n\n\nLet’s illustrate the above by an example:\n\nlocation = / {\n    [ configuration A ]\n}\n\nlocation / {\n    [ configuration B ]\n}\n\nlocation /documents/ {\n    [ configuration C ]\n}\n\nlocation ^~ /images/ {\n    [ configuration D ]\n}\n\nlocation ~* \\.(gif|jpg|jpeg)$ {\n    [ configuration E ]\n}\n\n \nThe “/” request will match configuration A,\nthe “/index.html” request will match configuration B,\nthe “/documents/document.html” request will match\nconfiguration C,\nthe “/images/1.gif” request will match configuration D, and\nthe “/documents/1.jpg” request will match configuration E.\n\n\nThe “@” prefix defines a named location.\nSuch a location is not used for a regular request processing, but instead\nused for request redirection.\nThey cannot be nested, and cannot contain nested locations.\n\n\nIf a location is defined by a prefix string that ends with the slash character,\nand requests are processed by one of\nproxy_pass,\nfastcgi_pass,\nuwsgi_pass,\nscgi_pass,\nmemcached_pass, or\ngrpc_pass,\nthen the special processing is performed.\nIn response to a request with URI equal to this string,\nbut without the trailing slash,\na permanent redirect with the code 301 will be returned to the requested URI\nwith the slash appended.\nIf this is not desired, an exact match of the URI and location could be\ndefined like this:\n\nlocation /user/ {\n    proxy_pass http://user.example.com;\n}\n\nlocation = /user {\n    proxy_pass http://login.example.com;\n}\n\n \n"
        },
        {
          "name": "log_not_found",
          "syntax": "log_not_found on | off;",
          "default": "log_not_found on;",
          "context": "http, server, location",
          "description": "\nEnables or disables logging of errors about not found files into\nerror_log.\n"
        },
        {
          "name": "log_subrequest",
          "syntax": "log_subrequest on | off;",
          "default": "log_subrequest off;",
          "context": "http, server, location",
          "description": "\nEnables or disables logging of subrequests into\naccess_log.\n"
        },
        {
          "name": "max_ranges",
          "syntax": "max_ranges number;",
          "context": "http, server, location",
          "description": "\nLimits the maximum allowed number of ranges in byte-range requests.\nRequests that exceed the limit are processed as if there were no\nbyte ranges specified.\nBy default, the number of ranges is not limited.\nThe zero value disables the byte-range support completely.\n"
        },
        {
          "name": "merge_slashes",
          "syntax": "merge_slashes on | off;",
          "default": "merge_slashes on;",
          "context": "http, server",
          "description": "\nEnables or disables compression of two or more adjacent slashes\nin a URI into a single slash.\n\n\nNote that compression is essential for the correct matching of prefix string\nand regular expression locations.\nWithout it, the “//scripts/one.php” request would not match\n\nlocation /scripts/ {\n    ...\n}\n\n \nand might be processed as a static file.\nSo it gets converted to “/scripts/one.php”.\n\n\nTurning the compression off can become necessary if a URI\ncontains base64-encoded names, since base64 uses the “/”\ncharacter internally.\nHowever, for security considerations, it is better to avoid turning\nthe compression off.\n\n\nIf the directive is specified on the server level,\nits value is only used if a server is a default one.\nThe value specified also applies to all virtual servers\nlistening on the same address and port.\n"
        },
        {
          "name": "msie_padding",
          "syntax": "msie_padding on | off;",
          "default": "msie_padding on;",
          "context": "http, server, location",
          "description": "\nEnables or disables adding comments to responses for MSIE clients with status\ngreater than 400 to increase the response size to 512 bytes.\n"
        },
        {
          "name": "msie_refresh",
          "syntax": "msie_refresh on | off;",
          "default": "msie_refresh off;",
          "context": "http, server, location",
          "description": "\nEnables or disables issuing refreshes instead of redirects for MSIE clients.\n"
        },
        {
          "name": "open_file_cache",
          "syntax": "open_file_cache off;open_file_cache max=N [inactive=time];",
          "default": "open_file_cache off;",
          "context": "http, server, location",
          "description": "\nConfigures a cache that can store:\n\n\n\n\nopen file descriptors, their sizes and modification times;\n\n\n\ninformation on existence of directories;\n\n\n\nfile lookup errors, such as “file not found”, “no read permission”,\nand so on.\n\nCaching of errors should be enabled separately by the\nopen_file_cache_errors\ndirective.\n\n\n\n\n \n\n\nThe directive has the following parameters:\n\n\n\n\nmax\n\n\nsets the maximum number of elements in the cache;\non cache overflow the least recently used (LRU) elements are removed;\n\n\n\ninactive\n\n\ndefines a time after which an element is removed from the cache\nif it has not been accessed during this time;\nby default, it is 60 seconds;\n\n\n\noff\n\n\ndisables the cache.\n\n\n\n \n\n\nExample:\n\nopen_file_cache          max=1000 inactive=20s;\nopen_file_cache_valid    30s;\nopen_file_cache_min_uses 2;\nopen_file_cache_errors   on;\n\n \n"
        },
        {
          "name": "open_file_cache_errors",
          "syntax": "open_file_cache_errors on | off;",
          "default": "open_file_cache_errors off;",
          "context": "http, server, location",
          "description": "\nEnables or disables caching of file lookup errors by\nopen_file_cache.\n"
        },
        {
          "name": "open_file_cache_min_uses",
          "syntax": "open_file_cache_min_uses number;",
          "default": "open_file_cache_min_uses 1;",
          "context": "http, server, location",
          "description": "\nSets the minimum number of file accesses during\nthe period configured by the inactive parameter\nof the open_file_cache directive, required for a file\ndescriptor to remain open in the cache.\n"
        },
        {
          "name": "open_file_cache_valid",
          "syntax": "open_file_cache_valid time;",
          "default": "open_file_cache_valid 60s;",
          "context": "http, server, location",
          "description": "\nSets a time after which\nopen_file_cache\nelements should be validated.\n\n"
        },
        {
          "name": "output_buffers",
          "syntax": "output_buffers number size;",
          "default": "output_buffers 2 32k;",
          "context": "http, server, location",
          "description": "\nSets the number and size of the\nbuffers used for reading a response from a disk.\n\n\nPrior to version 1.9.5, the default value was 1 32k.\n\n \n"
        },
        {
          "name": "port_in_redirect",
          "syntax": "port_in_redirect on | off;",
          "default": "port_in_redirect on;",
          "context": "http, server, location",
          "description": "\nEnables or disables specifying the port in\nabsolute redirects issued by nginx.\n\n\nThe use of the primary server name in redirects is controlled by\nthe server_name_in_redirect directive.\n"
        },
        {
          "name": "postpone_output",
          "syntax": "postpone_output size;",
          "default": "postpone_output 1460;",
          "context": "http, server, location",
          "description": "\nIf possible, the transmission of client data will be postponed until\nnginx has at least size bytes of data to send.\nThe zero value disables postponing data transmission.\n"
        },
        {
          "name": "read_ahead",
          "syntax": "read_ahead size;",
          "default": "read_ahead 0;",
          "context": "http, server, location",
          "description": "\nSets the amount of pre-reading for the kernel when working with file.\n\n\nOn Linux, the\nposix_fadvise(0, 0, 0, POSIX_FADV_SEQUENTIAL)\nsystem call is used, and so the size parameter is ignored.\n\n\nOn FreeBSD, the\nfcntl(O_READAHEAD,\nsize)\nsystem call, supported since FreeBSD 9.0-CURRENT, is used.\nFreeBSD 7 has to be\npatched.\n"
        },
        {
          "name": "recursive_error_pages",
          "syntax": "recursive_error_pages on | off;",
          "default": "recursive_error_pages off;",
          "context": "http, server, location",
          "description": "\nEnables or disables doing several redirects using the\nerror_page\ndirective.\nThe number of such redirects is limited.\n"
        },
        {
          "name": "request_pool_size",
          "syntax": "request_pool_size size;",
          "default": "request_pool_size 4k;",
          "context": "http, server",
          "description": "\nAllows accurate tuning of per-request memory allocations.\nThis directive has minimal impact on performance\nand should not generally be used.\n"
        },
        {
          "name": "reset_timedout_connection",
          "syntax": "reset_timedout_connection on | off;",
          "default": "reset_timedout_connection off;",
          "context": "http, server, location",
          "description": "\nEnables or disables resetting timed out connections\nand connections\nclosed\nwith the non-standard code 444 (1.15.2).\nThe reset is performed as follows.\nBefore closing a socket, the\nSO_LINGER\noption is set on it with a timeout value of 0.\nWhen the socket is closed, TCP RST is sent to the client, and all memory\noccupied by this socket is released.\nThis helps avoid keeping an already closed socket with filled buffers\nin a FIN_WAIT1 state for a long time.\n\n\nIt should be noted that timed out keep-alive connections are\nclosed normally.\n"
        },
        {
          "name": "resolver",
          "syntax": "resolver address ... [valid=time] [ipv6=on|off];",
          "context": "http, server, location",
          "description": "\nConfigures name servers used to resolve names of upstream servers\ninto addresses, for example:\n\nresolver 127.0.0.1 [::1]:5353;\n\n \nAn address can be specified as a domain name or IP address,\nand an optional port (1.3.1, 1.2.2).\nIf port is not specified, the port 53 is used.\nName servers are queried in a round-robin fashion.\n\n\nBefore version 1.1.7, only a single name server could be configured.\nSpecifying name servers using IPv6 addresses is supported\nstarting from versions 1.3.1 and 1.2.2.\n\n \nBy default, nginx will look up both IPv4 and IPv6 addresses while resolving.\nIf looking up of IPv6 addresses is not desired,\nthe ipv6=off parameter can be specified.\n\n\nResolving of names into IPv6 addresses is supported\nstarting from version 1.5.8.\n\n \nBy default, nginx caches answers using the TTL value of a response.\nAn optional valid parameter allows overriding it:\n\nresolver 127.0.0.1 [::1]:5353 valid=30s;\n\n \n\n\nBefore version 1.1.9, tuning of caching time was not possible,\nand nginx always cached answers for the duration of 5 minutes.\n\n \n\n\nTo prevent DNS spoofing, it is recommended\nconfiguring DNS servers in a properly secured trusted local network.\n\n \n"
        },
        {
          "name": "resolver_timeout",
          "syntax": "resolver_timeout time;",
          "default": "resolver_timeout 30s;",
          "context": "http, server, location",
          "description": "\nSets a timeout for name resolution, for example:\n\nresolver_timeout 5s;\n\n \n"
        },
        {
          "name": "root",
          "syntax": "root path;",
          "default": "root html;",
          "context": "http, server, location, if in location",
          "description": "\nSets the root directory for requests.\nFor example, with the following configuration\n\nlocation /i/ {\n    root /data/w3;\n}\n\n \nThe /data/w3/i/top.gif file will be sent in response to\nthe “/i/top.gif” request.\n\n\nThe path value can contain variables,\nexcept $document_root and $realpath_root.\n\n\nA path to the file is constructed by merely adding a URI to the value\nof the root directive.\nIf a URI has to be modified, the\nalias directive should be used.\n"
        },
        {
          "name": "satisfy",
          "syntax": "satisfy all | any;",
          "default": "satisfy all;",
          "context": "http, server, location",
          "description": "\nAllows access if all (all) or at least one\n(any) of the\nngx_http_access_module,\nngx_http_auth_basic_module,\nngx_http_auth_request_module,\nor\nngx_http_auth_jwt_module\nmodules allow access.\n\n\nExample:\n\nlocation / {\n    satisfy any;\n\n    allow 192.168.1.0/32;\n    deny  all;\n\n    auth_basic           \"closed site\";\n    auth_basic_user_file conf/htpasswd;\n}\n\n \n"
        },
        {
          "name": "send_lowat",
          "syntax": "send_lowat size;",
          "default": "send_lowat 0;",
          "context": "http, server, location",
          "description": "\nIf the directive is set to a non-zero value, nginx will try to minimize\nthe number of send operations on client sockets by using either\nNOTE_LOWAT flag of the\nkqueue method\nor the SO_SNDLOWAT socket option.\nIn both cases the specified size is used.\n\n\nThis directive is ignored on Linux, Solaris, and Windows.\n"
        },
        {
          "name": "send_timeout",
          "syntax": "send_timeout time;",
          "default": "send_timeout 60s;",
          "context": "http, server, location",
          "description": "\nSets a timeout for transmitting a response to the client.\nThe timeout is set only between two successive write operations,\nnot for the transmission of the whole response.\nIf the client does not receive anything within this time,\nthe connection is closed.\n"
        },
        {
          "name": "sendfile",
          "syntax": "sendfile on | off;",
          "default": "sendfile off;",
          "context": "http, server, location, if in location",
          "description": "\nEnables or disables the use of\nsendfile().\n\n\nStarting from nginx 0.8.12 and FreeBSD 5.2.1,\naio can be used to pre-load data\nfor sendfile():\n\nlocation /video/ {\n    sendfile       on;\n    tcp_nopush     on;\n    aio            on;\n}\n\n \nIn this configuration, sendfile() is called with\nthe SF_NODISKIO flag which causes it not to block on disk I/O,\nbut, instead, report back that the data are not in memory.\nnginx then initiates an asynchronous data load by reading one byte.\nOn the first read, the FreeBSD kernel loads the first 128K bytes\nof a file into memory, although next reads will only load data in 16K chunks.\nThis can be changed using the\nread_ahead directive.\n\n\nBefore version 1.7.11, pre-loading could be enabled with\naio sendfile;.\n\n \n"
        },
        {
          "name": "sendfile_max_chunk",
          "syntax": "sendfile_max_chunk size;",
          "default": "sendfile_max_chunk 0;",
          "context": "http, server, location",
          "description": "\nWhen set to a non-zero value, limits the amount of data that can be\ntransferred in a single sendfile() call.\nWithout the limit, one fast connection may seize the worker process entirely.\n"
        },
        {
          "name": "server",
          "syntax": "server { ... }",
          "context": "http",
          "description": "\nSets configuration for a virtual server.\nThere is no clear separation between IP-based (based on the IP address)\nand name-based (based on the “Host” request header field)\nvirtual servers.\nInstead, the listen directives describe all\naddresses and ports that should accept connections for the server, and the\nserver_name directive lists all server names.\nExample configurations are provided in the\n“How nginx processes a request” document.\n"
        },
        {
          "name": "server_name",
          "syntax": "server_name name ...;",
          "default": "server_name \"\";",
          "context": "server",
          "description": "\nSets names of a virtual server, for example:\n\nserver {\n    server_name example.com www.example.com;\n}\n\n \n\n\nThe first name becomes the primary server name.\n\n\nServer names can include an asterisk (“*”)\nreplacing the first or last part of a name:\n\nserver {\n    server_name example.com *.example.com www.example.*;\n}\n\n \nSuch names are called wildcard names.\n\n\nThe first two of the names mentioned above can be combined in one:\n\nserver {\n    server_name .example.com;\n}\n\n \n\n\nIt is also possible to use regular expressions in server names,\npreceding the name with a tilde (“~”):\n\nserver {\n    server_name www.example.com ~^www\\d+\\.example\\.com$;\n}\n\n \n\n\nRegular expressions can contain captures (0.7.40) that can later\nbe used in other directives:\n\nserver {\n    server_name ~^(www\\.)?(.+)$;\n\n    location / {\n        root /sites/$2;\n    }\n}\n\nserver {\n    server_name _;\n\n    location / {\n        root /sites/default;\n    }\n}\n\n \n\n\nNamed captures in regular expressions create variables (0.8.25)\nthat can later be used in other directives:\n\nserver {\n    server_name ~^(www\\.)?(?<domain>.+)$;\n\n    location / {\n        root /sites/$domain;\n    }\n}\n\nserver {\n    server_name _;\n\n    location / {\n        root /sites/default;\n    }\n}\n\n \n\n\nIf the directive’s parameter is set to “$hostname” (0.9.4), the\nmachine’s hostname is inserted.\n\n\nIt is also possible to specify an empty server name (0.7.11):\n\nserver {\n    server_name www.example.com \"\";\n}\n\n \nIt allows this server to process requests without the “Host”\nheader field — instead of the default server — for the given address:port pair.\nThis is the default setting.\n\n\nBefore 0.8.48, the machine’s hostname was used by default.\n\n \n\n\nDuring searching for a virtual server by name,\nif the name matches more than one of the specified variants,\n(e.g. both a wildcard name and regular expression match), the first matching\nvariant will be chosen, in the following order of priority:\n\n\n\n\nthe exact name\n\n\n\nthe longest wildcard name starting with an asterisk,\ne.g. “*.example.com”\n\n\n\nthe longest wildcard name ending with an asterisk,\ne.g. “mail.*”\n\n\n\nthe first matching regular expression\n(in order of appearance in the configuration file)\n\n\n\n \n\n\nDetailed description of server names is provided in a separate\nServer names document.\n"
        },
        {
          "name": "server_name_in_redirect",
          "syntax": "server_name_in_redirect on | off;",
          "default": "server_name_in_redirect off;",
          "context": "http, server, location",
          "description": "\nEnables or disables the use of the primary server name, specified by the\nserver_name directive,\nin absolute redirects issued by nginx.\nWhen the use of the primary server name is disabled, the name from the\n“Host” request header field is used.\nIf this field is not present, the IP address of the server is used.\n\n\nThe use of a port in redirects is controlled by\nthe port_in_redirect directive.\n"
        },
        {
          "name": "server_names_hash_bucket_size",
          "syntax": "server_names_hash_bucket_size size;",
          "default": "server_names_hash_bucket_size 32|64|128;",
          "context": "http",
          "description": "\nSets the bucket size for the server names hash tables.\nThe default value depends on the size of the processor’s cache line.\nThe details of setting up hash tables are provided in a separate\ndocument.\n"
        },
        {
          "name": "server_names_hash_max_size",
          "syntax": "server_names_hash_max_size size;",
          "default": "server_names_hash_max_size 512;",
          "context": "http",
          "description": "\nSets the maximum size of the server names hash tables.\nThe details of setting up hash tables are provided in a separate\ndocument.\n"
        },
        {
          "name": "server_tokens",
          "syntax": "server_tokens on | off | build | string;",
          "default": "server_tokens on;",
          "context": "http, server, location",
          "description": "\nEnables or disables emitting nginx version on error pages and in the\n“Server” response header field.\n"
        },
        {
          "name": "subrequest_output_buffer_size",
          "syntax": "subrequest_output_buffer_size size;",
          "default": "subrequest_output_buffer_size 4k|8k;",
          "context": "http, server, location",
          "description": "\nSets the size of the buffer used for\nstoring the response body of a subrequest.\nBy default, the buffer size is equal to one memory page.\nThis is either 4K or 8K, depending on a platform.\nIt can be made smaller, however.\n\n\nThe directive is applicable only for subrequests\nwith response bodies saved into memory.\nFor example, such subrequests are created by\nSSI.\n"
        },
        {
          "name": "tcp_nodelay",
          "syntax": "tcp_nodelay on | off;",
          "default": "tcp_nodelay on;",
          "context": "http, server, location",
          "description": "\nEnables or disables the use of the TCP_NODELAY option.\nThe option is enabled when a connection is transitioned into the\nkeep-alive state.\nAdditionally, it is enabled on SSL connections,\nfor unbuffered proxying,\nand for WebSocket proxying.\n"
        },
        {
          "name": "tcp_nopush",
          "syntax": "tcp_nopush on | off;",
          "default": "tcp_nopush off;",
          "context": "http, server, location",
          "description": "\nEnables or disables the use of\nthe TCP_NOPUSH socket option on FreeBSD\nor the TCP_CORK socket option on Linux.\nThe options are enabled only when sendfile is used.\nEnabling the option allows\n\n\n\n\nsending the response header and the beginning of a file in one packet,\non Linux and FreeBSD 4.*;\n\n\n\nsending a file in full packets.\n\n\n\n \n"
        },
        {
          "name": "try_files",
          "syntax": "try_files file ... uri;try_files file ... =code;",
          "context": "server, location",
          "description": "\nChecks the existence of files in the specified order and uses\nthe first found file for request processing; the processing\nis performed in the current context.\nThe path to a file is constructed from the\nfile parameter\naccording to the\nroot and alias directives.\nIt is possible to check directory’s existence by specifying\na slash at the end of a name, e.g. “$uri/”.\nIf none of the files were found, an internal redirect to the\nuri specified in the last parameter is made.\nFor example:\n\nlocation /images/ {\n    try_files $uri /images/default.gif;\n}\n\nlocation = /images/default.gif {\n    expires 30s;\n}\n\n \nThe last parameter can also point to a named location,\nas shown in examples below.\nStarting from version 0.7.51, the last parameter can also be a\ncode:\n\nlocation / {\n    try_files $uri $uri/index.html $uri.html =404;\n}\n\n \n\n\nExample in proxying Mongrel:\n\nlocation / {\n    try_files /system/maintenance.html\n              $uri $uri/index.html $uri.html\n              @mongrel;\n}\n\nlocation @mongrel {\n    proxy_pass http://mongrel;\n}\n\n \n\n\nExample for Drupal/FastCGI:\n\nlocation / {\n    try_files $uri $uri/ @drupal;\n}\n\nlocation ~ \\.php$ {\n    try_files $uri @drupal;\n\n    fastcgi_pass ...;\n\n    fastcgi_param SCRIPT_FILENAME /path/to$fastcgi_script_name;\n    fastcgi_param SCRIPT_NAME     $fastcgi_script_name;\n    fastcgi_param QUERY_STRING    $args;\n\n    ... other fastcgi_param's\n}\n\nlocation @drupal {\n    fastcgi_pass ...;\n\n    fastcgi_param SCRIPT_FILENAME /path/to/index.php;\n    fastcgi_param SCRIPT_NAME     /index.php;\n    fastcgi_param QUERY_STRING    q=$uri&$args;\n\n    ... other fastcgi_param's\n}\n\n \nIn the following example,\n\nlocation / {\n    try_files $uri $uri/ @drupal;\n}\n\n \nthe try_files directive is equivalent to\n\nlocation / {\n    error_page 404 = @drupal;\n    log_not_found off;\n}\n\n \nAnd here,\n\nlocation ~ \\.php$ {\n    try_files $uri @drupal;\n\n    fastcgi_pass ...;\n\n    fastcgi_param SCRIPT_FILENAME /path/to$fastcgi_script_name;\n\n    ...\n}\n\n \ntry_files checks the existence of the PHP file\nbefore passing the request to the FastCGI server.\n\n\nExample for Wordpress and Joomla:\n\nlocation / {\n    try_files $uri $uri/ @wordpress;\n}\n\nlocation ~ \\.php$ {\n    try_files $uri @wordpress;\n\n    fastcgi_pass ...;\n\n    fastcgi_param SCRIPT_FILENAME /path/to$fastcgi_script_name;\n    ... other fastcgi_param's\n}\n\nlocation @wordpress {\n    fastcgi_pass ...;\n\n    fastcgi_param SCRIPT_FILENAME /path/to/index.php;\n    ... other fastcgi_param's\n}\n\n \n"
        },
        {
          "name": "types",
          "syntax": "types { ... }",
          "default": "types { text/html html; image/gif gif; image/jpeg jpg; }",
          "context": "http, server, location",
          "description": "\nMaps file name extensions to MIME types of responses.\nExtensions are case-insensitive.\nSeveral extensions can be mapped to one type, for example:\n\ntypes {\n    application/octet-stream bin exe dll;\n    application/octet-stream deb;\n    application/octet-stream dmg;\n}\n\n \n\n\nA sufficiently full mapping table is distributed with nginx in the\nconf/mime.types file.\n\n\nTo make a particular location emit the\n“application/octet-stream”\nMIME type for all requests, the following configuration can be used:\n\nlocation /download/ {\n    types        { }\n    default_type application/octet-stream;\n}\n\n \n"
        },
        {
          "name": "types_hash_bucket_size",
          "syntax": "types_hash_bucket_size size;",
          "default": "types_hash_bucket_size 64;",
          "context": "http, server, location",
          "description": "\nSets the bucket size for the types hash tables.\nThe details of setting up hash tables are provided in a separate\ndocument.\n\n\nPrior to version 1.5.13,\nthe default value depended on the size of the processor’s cache line.\n\n \n"
        },
        {
          "name": "types_hash_max_size",
          "syntax": "types_hash_max_size size;",
          "default": "types_hash_max_size 1024;",
          "context": "http, server, location",
          "description": "\nSets the maximum size of the types hash tables.\nThe details of setting up hash tables are provided in a separate\ndocument.\n"
        },
        {
          "name": "underscores_in_headers",
          "syntax": "underscores_in_headers on | off;",
          "default": "underscores_in_headers off;",
          "context": "http, server",
          "description": "\nEnables or disables the use of underscores in client request header fields.\nWhen the use of underscores is disabled, request header fields whose names\ncontain underscores are\nmarked as invalid and become subject to the\nignore_invalid_headers directive.\n\n\nIf the directive is specified on the server level,\nits value is only used if a server is a default one.\nThe value specified also applies to all virtual servers\nlistening on the same address and port.\n"
        },
        {
          "name": "variables_hash_bucket_size",
          "syntax": "variables_hash_bucket_size size;",
          "default": "variables_hash_bucket_size 64;",
          "context": "http",
          "description": "\nSets the bucket size for the variables hash table.\nThe details of setting up hash tables are provided in a separate\ndocument.\n"
        },
        {
          "name": "variables_hash_max_size",
          "syntax": "variables_hash_max_size size;",
          "default": "variables_hash_max_size 1024;",
          "context": "http",
          "description": "\nSets the maximum size of the variables hash table.\nThe details of setting up hash tables are provided in a separate\ndocument.\n\n\nPrior to version 1.5.13, the default value was 512.\n\n \n"
        }
      ]
    },
    {
      "name": "ngx_http_access_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_access_module.html",
      "directives": [
        {
          "name": "allow",
          "syntax": "allow address | CIDR | unix: | all;",
          "context": "http, server, location, limit_except",
          "description": "\nAllows access for the specified network or address.\nIf the special value unix: is specified (1.5.1),\nallows access for all UNIX-domain sockets.\n"
        },
        {
          "name": "deny",
          "syntax": "deny address | CIDR | unix: | all;",
          "context": "http, server, location, limit_except",
          "description": "\nDenies access for the specified network or address.\nIf the special value unix: is specified (1.5.1),\ndenies access for all UNIX-domain sockets.\n"
        }
      ]
    },
    {
      "name": "ngx_http_addition_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_addition_module.html",
      "directives": [
        {
          "name": "add_before_body",
          "syntax": "add_before_body uri;",
          "context": "http, server, location",
          "description": "\nAdds the text returned as a result of processing a given subrequest\nbefore the response body.\nAn empty string (\"\") as a parameter cancels addition\ninherited from the previous configuration level.\n"
        },
        {
          "name": "add_after_body",
          "syntax": "add_after_body uri;",
          "context": "http, server, location",
          "description": "\nAdds the text returned as a result of processing a given subrequest\nafter the response body.\nAn empty string (\"\") as a parameter cancels addition\ninherited from the previous configuration level.\n"
        },
        {
          "name": "addition_types",
          "syntax": "addition_types mime-type ...;",
          "default": "addition_types text/html;",
          "context": "http, server, location",
          "description": "\nAllows adding text in responses with the specified MIME types,\nin addition to “text/html”.\nThe special value “*” matches any MIME type (0.8.29).\n"
        }
      ]
    },
    {
      "name": "ngx_http_api_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_api_module.html",
      "directives": [
        {
          "name": "api",
          "syntax": "api [write=on|off];",
          "context": "location",
          "description": "\nTurns on the REST API interface in the surrounding location.\nAccess to this location should be\nlimited.\n\n\nThe write parameter determines whether the API\nis read-only or read-write.\nBy default, the API is read-only.\n"
        },
        {
          "name": "status_zone",
          "syntax": "status_zone zone;",
          "context": "server",
          "description": "\nEnables collection of virtual\nhttp\nor\nstream\nserver status information in the specified zone.\nSeveral servers may share the same zone.\n"
        }
      ]
    },
    {
      "name": "ngx_http_auth_basic_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_auth_basic_module.html",
      "directives": [
        {
          "name": "auth_basic",
          "syntax": "auth_basic string | off;",
          "default": "auth_basic off;",
          "context": "http, server, location, limit_except",
          "description": "\nEnables validation of user name and password using the\n“HTTP Basic Authentication” protocol.\nThe specified parameter is used as a realm.\nParameter value can contain variables (1.3.10, 1.2.7).\nThe special value off allows cancelling the effect\nof the auth_basic directive\ninherited from the previous configuration level.\n"
        },
        {
          "name": "auth_basic_user_file",
          "syntax": "auth_basic_user_file file;",
          "context": "http, server, location, limit_except",
          "description": "\nSpecifies a file that keeps user names and passwords,\nin the following format:\n\n# comment\nname1:password1\nname2:password2:comment\nname3:password3\n\n \nThe file name can contain variables.\n\n\nThe following password types are supported:\n\n\n\n\nencrypted with the crypt() function; can be generated using\nthe “htpasswd” utility from the Apache HTTP Server\ndistribution or the “openssl passwd” command;\n\n\n\nhashed with the Apache variant of the MD5-based password algorithm (apr1);\ncan be generated with the same tools;\n\n\n\nspecified by the\n“{scheme}data”\nsyntax (1.0.3+) as described in\nRFC 2307;\ncurrently implemented schemes include PLAIN (an example one,\nshould not be used), SHA (1.3.13) (plain SHA-1\nhashing, should not be used) and SSHA (salted SHA-1 hashing,\nused by some software packages, notably OpenLDAP and Dovecot).\n\nSupport for SHA scheme was added only to aid\nin migration from other web servers.\nIt should not be used for new passwords, since unsalted SHA-1 hashing\nthat it employs is vulnerable to\nrainbow table\nattacks.\n\n\n\n\n \n"
        }
      ]
    },
    {
      "name": "ngx_http_auth_request_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_auth_request_module.html",
      "directives": [
        {
          "name": "auth_request",
          "syntax": "auth_request uri | off;",
          "default": "auth_request off;",
          "context": "http, server, location",
          "description": "\nEnables authorization based on the result of a subrequest and sets\nthe URI to which the subrequest will be sent.\n"
        },
        {
          "name": "auth_request_set",
          "syntax": "auth_request_set $variable value;",
          "context": "http, server, location",
          "description": "\nSets the request variable to the given\nvalue after the authorization request completes.\nThe value may contain variables from the authorization request,\nsuch as $upstream_http_*.\n"
        }
      ]
    },
    {
      "name": "ngx_http_browser_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_browser_module.html",
      "directives": [
        {
          "name": "ancient_browser",
          "syntax": "ancient_browser string ...;",
          "context": "http, server, location",
          "description": "\nIf any of the specified substrings is found in the “User-Agent”\nrequest header field, the browser will be considered ancient.\nThe special string “netscape4” corresponds to the\nregular expression “^Mozilla/[1-4]”.\n"
        },
        {
          "name": "ancient_browser_value",
          "syntax": "ancient_browser_value string;",
          "default": "ancient_browser_value 1;",
          "context": "http, server, location",
          "description": "\nSets a value for the $ancient_browser variables.\n"
        },
        {
          "name": "modern_browser",
          "syntax": "modern_browser browser version;modern_browser unlisted;",
          "context": "http, server, location",
          "description": "\nSpecifies a version starting from which a browser is considered modern.\nA browser can be any one of the following: msie,\ngecko (browsers based on Mozilla),\nopera, safari,\nor konqueror.\n\n\nVersions can be specified in the following formats: X, X.X, X.X.X, or X.X.X.X.\nThe maximum values for each of the format are\n4000, 4000.99, 4000.99.99, and 4000.99.99.99, respectively.\n\n\nThe special value unlisted specifies to consider\na browser as modern if it was not listed by the\nmodern_browser and ancient_browser\ndirectives.\nOtherwise such a browser is considered ancient.\nIf a request does not provide the “User-Agent” field\nin the header, the browser is treated as not being listed.\n"
        },
        {
          "name": "modern_browser_value",
          "syntax": "modern_browser_value string;",
          "default": "modern_browser_value 1;",
          "context": "http, server, location",
          "description": "\nSets a value for the $modern_browser variables.\n"
        }
      ]
    },
    {
      "name": "ngx_http_charset_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_charset_module.html",
      "directives": [
        {
          "name": "charset",
          "syntax": "charset charset | off;",
          "default": "charset off;",
          "context": "http, server, location, if in location",
          "description": "\nAdds the specified charset to the “Content-Type”\nresponse header field.\nIf this charset is different from the charset specified\nin the source_charset directive, a conversion is performed.\n\n\nThe parameter off cancels the addition of charset\nto the “Content-Type” response header field.\n\n\nA charset can be defined with a variable:\n\ncharset $charset;\n\n \nIn such a case, all possible values of a variable need to be present\nin the configuration at least once in the form of the\ncharset_map, charset, or\nsource_charset directives.\nFor utf-8, windows-1251, and\nkoi8-r charsets, it is sufficient to include the files\nconf/koi-win, conf/koi-utf, and\nconf/win-utf into configuration.\nFor other charsets, simply making a fictitious conversion table works,\nfor example:\n\ncharset_map iso-8859-5 _ { }\n\n \n\n\nIn addition, a charset can be set in the\n“X-Accel-Charset” response header field.\nThis capability can be disabled using the\nproxy_ignore_headers,\nfastcgi_ignore_headers,\nuwsgi_ignore_headers,\nscgi_ignore_headers,\nand\ngrpc_ignore_headers\ndirectives.\n"
        },
        {
          "name": "charset_map",
          "syntax": "charset_map charset1 charset2 { ... }",
          "context": "http",
          "description": "\nDescribes the conversion table from one charset to another.\nA reverse conversion table is built using the same data.\nCharacter codes are given in hexadecimal.\nMissing characters in the range 80-FF are replaced with “?”.\nWhen converting from UTF-8, characters missing in a one-byte charset\nare replaced with “&#XXXX;”.\n\n\nExample:\n\ncharset_map koi8-r windows-1251 {\n    C0 FE ; # small yu\n    C1 E0 ; # small a\n    C2 E1 ; # small b\n    C3 F6 ; # small ts\n    ...\n}\n\n \n\n\nWhen describing a conversion table to UTF-8, codes for the UTF-8 charset should\nbe given in the second column, for example:\n\ncharset_map koi8-r utf-8 {\n    C0 D18E ; # small yu\n    C1 D0B0 ; # small a\n    C2 D0B1 ; # small b\n    C3 D186 ; # small ts\n    ...\n}\n\n \n\n\nFull conversion tables from koi8-r to\nwindows-1251, and from koi8-r and\nwindows-1251 to utf-8\nare provided in the distribution files conf/koi-win,\nconf/koi-utf, and conf/win-utf.\n"
        },
        {
          "name": "charset_types",
          "syntax": "charset_types mime-type ...;",
          "default": "charset_types text/html text/xml text/plain text/vnd.wap.wml application/javascript application/rss+xml;",
          "context": "http, server, location",
          "description": "\nEnables module processing in responses with the specified MIME types\nin addition to “text/html”.\nThe special value “*” matches any MIME type (0.8.29).\n\n\n\n\nUntil version 1.5.4, “application/x-javascript” was used\nas the default MIME type instead of “application/javascript”.\n\n \n"
        },
        {
          "name": "override_charset",
          "syntax": "override_charset on | off;",
          "default": "override_charset off;",
          "context": "http, server, location, if in location",
          "description": "\nDetermines whether a conversion should be performed for answers\nreceived from a proxied or a FastCGI/uwsgi/SCGI/gRPC server\nwhen the answers already carry a charset in the “Content-Type”\nresponse header field.\nIf conversion is enabled, a charset specified in the received\nresponse is used as a source charset.\n\n\nIt should be noted that if a response is received in a subrequest\nthen the conversion from the response charset to the main request charset\nis always performed, regardless of the override_charset\ndirective setting.\n\n \n"
        },
        {
          "name": "source_charset",
          "syntax": "source_charset charset;",
          "context": "http, server, location, if in location",
          "description": "\nDefines the source charset of a response.\nIf this charset is different from the charset specified\nin the charset directive, a conversion is performed.\n"
        }
      ]
    },
    {
      "name": "ngx_http_empty_gif_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_empty_gif_module.html",
      "directives": [
        {
          "name": "empty_gif;",
          "syntax": "empty_gif;",
          "context": "location",
          "description": "\nTurns on module processing in a surrounding location.\n"
        }
      ]
    },
    {
      "name": "ngx_http_fastcgi_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_fastcgi_module.html",
      "directives": [
        {
          "name": "fastcgi_bind",
          "syntax": "fastcgi_bind address [transparent] | off;",
          "context": "http, server, location",
          "description": "\nMakes outgoing connections to a FastCGI server originate\nfrom the specified local IP address with an optional port (1.11.2).\nParameter value can contain variables (1.3.12).\nThe special value off (1.3.12) cancels the effect\nof the fastcgi_bind directive\ninherited from the previous configuration level, which allows the\nsystem to auto-assign the local IP address and port.\n"
        },
        {
          "name": "fastcgi_buffer_size",
          "syntax": "fastcgi_buffer_size size;",
          "default": "fastcgi_buffer_size 4k|8k;",
          "context": "http, server, location",
          "description": "\nSets the size of the buffer used for reading the first part\nof the response received from the FastCGI server.\nThis part usually contains a small response header.\nBy default, the buffer size is equal to one memory page.\nThis is either 4K or 8K, depending on a platform.\nIt can be made smaller, however.\n"
        },
        {
          "name": "fastcgi_buffering",
          "syntax": "fastcgi_buffering on | off;",
          "default": "fastcgi_buffering on;",
          "context": "http, server, location",
          "description": "\nEnables or disables buffering of responses from the FastCGI server.\n\n\nWhen buffering is enabled, nginx receives a response from the FastCGI server\nas soon as possible, saving it into the buffers set by the\nfastcgi_buffer_size and fastcgi_buffers directives.\nIf the whole response does not fit into memory, a part of it can be saved\nto a temporary file on the disk.\nWriting to temporary files is controlled by the\nfastcgi_max_temp_file_size and\nfastcgi_temp_file_write_size directives.\n\n\nWhen buffering is disabled, the response is passed to a client synchronously,\nimmediately as it is received.\nnginx will not try to read the whole response from the FastCGI server.\nThe maximum size of the data that nginx can receive from the server\nat a time is set by the fastcgi_buffer_size directive.\n\n\nBuffering can also be enabled or disabled by passing\n“yes” or “no” in the\n“X-Accel-Buffering” response header field.\nThis capability can be disabled using the\nfastcgi_ignore_headers directive.\n"
        },
        {
          "name": "fastcgi_buffers",
          "syntax": "fastcgi_buffers number size;",
          "default": "fastcgi_buffers 8 4k|8k;",
          "context": "http, server, location",
          "description": "\nSets the number and size of the\nbuffers used for reading a response from the FastCGI server,\nfor a single connection.\nBy default, the buffer size is equal to one memory page.\nThis is either 4K or 8K, depending on a platform.\n"
        },
        {
          "name": "fastcgi_busy_buffers_size",
          "syntax": "fastcgi_busy_buffers_size size;",
          "default": "fastcgi_busy_buffers_size 8k|16k;",
          "context": "http, server, location",
          "description": "\nWhen buffering of responses from the FastCGI\nserver is enabled, limits the total size of buffers that\ncan be busy sending a response to the client while the response is not\nyet fully read.\nIn the meantime, the rest of the buffers can be used for reading the response\nand, if needed, buffering part of the response to a temporary file.\nBy default, size is limited by the size of two buffers set by the\nfastcgi_buffer_size and fastcgi_buffers directives.\n"
        },
        {
          "name": "fastcgi_cache",
          "syntax": "fastcgi_cache zone | off;",
          "default": "fastcgi_cache off;",
          "context": "http, server, location",
          "description": "\nDefines a shared memory zone used for caching.\nThe same zone can be used in several places.\nParameter value can contain variables (1.7.9).\nThe off parameter disables caching inherited\nfrom the previous configuration level.\n"
        },
        {
          "name": "fastcgi_cache_background_update",
          "syntax": "fastcgi_cache_background_update on | off;",
          "default": "fastcgi_cache_background_update off;",
          "context": "http, server, location",
          "description": "\nAllows starting a background subrequest\nto update an expired cache item,\nwhile a stale cached response is returned to the client.\nNote that it is necessary to\nallow\nthe usage of a stale cached response when it is being updated.\n"
        },
        {
          "name": "fastcgi_cache_bypass",
          "syntax": "fastcgi_cache_bypass string ...;",
          "context": "http, server, location",
          "description": "\nDefines conditions under which the response will not be taken from a cache.\nIf at least one value of the string parameters is not empty and is not\nequal to “0” then the response will not be taken from the cache:\n\nfastcgi_cache_bypass $cookie_nocache $arg_nocache$arg_comment;\nfastcgi_cache_bypass $http_pragma    $http_authorization;\n\n \nCan be used along with the fastcgi_no_cache directive.\n"
        },
        {
          "name": "fastcgi_cache_key",
          "syntax": "fastcgi_cache_key string;",
          "context": "http, server, location",
          "description": "\nDefines a key for caching, for example\n\nfastcgi_cache_key localhost:9000$request_uri;\n\n \n"
        },
        {
          "name": "fastcgi_cache_lock",
          "syntax": "fastcgi_cache_lock on | off;",
          "default": "fastcgi_cache_lock off;",
          "context": "http, server, location",
          "description": "\nWhen enabled, only one request at a time will be allowed to populate\na new cache element identified according to the fastcgi_cache_key\ndirective by passing a request to a FastCGI server.\nOther requests of the same cache element will either wait\nfor a response to appear in the cache or the cache lock for\nthis element to be released, up to the time set by the\nfastcgi_cache_lock_timeout directive.\n"
        },
        {
          "name": "fastcgi_cache_lock_age",
          "syntax": "fastcgi_cache_lock_age time;",
          "default": "fastcgi_cache_lock_age 5s;",
          "context": "http, server, location",
          "description": "\nIf the last request passed to the FastCGI server\nfor populating a new cache element\nhas not completed for the specified time,\none more request may be passed to the FastCGI server.\n"
        },
        {
          "name": "fastcgi_cache_lock_timeout",
          "syntax": "fastcgi_cache_lock_timeout time;",
          "default": "fastcgi_cache_lock_timeout 5s;",
          "context": "http, server, location",
          "description": "\nSets a timeout for fastcgi_cache_lock.\nWhen the time expires,\nthe request will be passed to the FastCGI server,\nhowever, the response will not be cached.\n\n\nBefore 1.7.8, the response could be cached.\n\n \n"
        },
        {
          "name": "fastcgi_cache_max_range_offset",
          "syntax": "fastcgi_cache_max_range_offset number;",
          "context": "http, server, location",
          "description": "\nSets an offset in bytes for byte-range requests.\nIf the range is beyond the offset,\nthe range request will be passed to the FastCGI server\nand the response will not be cached.\n"
        },
        {
          "name": "fastcgi_cache_methods",
          "syntax": "fastcgi_cache_methods GET | HEAD | POST ...;",
          "default": "fastcgi_cache_methods GET HEAD;",
          "context": "http, server, location",
          "description": "\nIf the client request method is listed in this directive then\nthe response will be cached.\n“GET” and “HEAD” methods are always\nadded to the list, though it is recommended to specify them explicitly.\nSee also the fastcgi_no_cache directive.\n"
        },
        {
          "name": "fastcgi_cache_min_uses",
          "syntax": "fastcgi_cache_min_uses number;",
          "default": "fastcgi_cache_min_uses 1;",
          "context": "http, server, location",
          "description": "\nSets the number of requests after which the response\nwill be cached.\n"
        },
        {
          "name": "fastcgi_cache_revalidate",
          "syntax": "fastcgi_cache_revalidate on | off;",
          "default": "fastcgi_cache_revalidate off;",
          "context": "http, server, location",
          "description": "\nEnables revalidation of expired cache items using conditional requests with\nthe “If-Modified-Since” and “If-None-Match”\nheader fields.\n"
        },
        {
          "name": "fastcgi_cache_use_stale",
          "syntax": "fastcgi_cache_use_stale error | timeout | invalid_header | updating | http_500 | http_503 | http_403 | http_404 | http_429 | off ...;",
          "default": "fastcgi_cache_use_stale off;",
          "context": "http, server, location",
          "description": "\nDetermines in which cases a stale cached response can be used\nwhen an error occurs during communication with the FastCGI server.\nThe directive’s parameters match the parameters of the\nfastcgi_next_upstream directive.\n\n\nThe error parameter also permits\nusing a stale cached response if a FastCGI server to process a request\ncannot be selected.\n"
        },
        {
          "name": "fastcgi_cache_valid",
          "syntax": "fastcgi_cache_valid [code ...] time;",
          "context": "http, server, location",
          "description": "\nSets caching time for different response codes.\nFor example, the following directives\n\nfastcgi_cache_valid 200 302 10m;\nfastcgi_cache_valid 404      1m;\n\n \nset 10 minutes of caching for responses with codes 200 and 302\nand 1 minute for responses with code 404.\n\n\nIf only caching time is specified\n\nfastcgi_cache_valid 5m;\n\n \nthen only 200, 301, and 302 responses are cached.\n\n\nIn addition, the any parameter can be specified\nto cache any responses:\n\nfastcgi_cache_valid 200 302 10m;\nfastcgi_cache_valid 301      1h;\nfastcgi_cache_valid any      1m;\n\n \n\n\nParameters of caching can also be set directly\nin the response header.\nThis has higher priority than setting of caching time using the directive.\n\n\n\n\nThe “X-Accel-Expires” header field sets caching time of a\nresponse in seconds.\nThe zero value disables caching for a response.\nIf the value starts with the @ prefix, it sets an absolute\ntime in seconds since Epoch, up to which the response may be cached.\n\n\n\nIf the header does not include the “X-Accel-Expires” field,\nparameters of caching may be set in the header fields\n“Expires” or “Cache-Control”.\n\n\n\nIf the header includes the “Set-Cookie” field, such a\nresponse will not be cached.\n\n\n\nIf the header includes the “Vary” field\nwith the special value “*”, such a\nresponse will not be cached (1.7.7).\nIf the header includes the “Vary” field\nwith another value, such a response will be cached\ntaking into account the corresponding request header fields (1.7.7).\n\n\n\n \nProcessing of one or more of these response header fields can be disabled\nusing the fastcgi_ignore_headers directive.\n"
        },
        {
          "name": "fastcgi_catch_stderr",
          "syntax": "fastcgi_catch_stderr string;",
          "context": "http, server, location",
          "description": "\nSets a string to search for in the error stream of a response\nreceived from a FastCGI server.\nIf the string is found then it is considered that the FastCGI\nserver has returned an invalid response.\nThis allows handling application errors in nginx, for example:\n\nlocation /php/ {\n    fastcgi_pass backend:9000;\n    ...\n    fastcgi_catch_stderr \"PHP Fatal error\";\n    fastcgi_next_upstream error timeout invalid_header;\n}\n\n \n"
        },
        {
          "name": "fastcgi_connect_timeout",
          "syntax": "fastcgi_connect_timeout time;",
          "default": "fastcgi_connect_timeout 60s;",
          "context": "http, server, location",
          "description": "\nDefines a timeout for establishing a connection with a FastCGI server.\nIt should be noted that this timeout cannot usually exceed 75 seconds.\n"
        },
        {
          "name": "fastcgi_force_ranges",
          "syntax": "fastcgi_force_ranges on | off;",
          "default": "fastcgi_force_ranges off;",
          "context": "http, server, location",
          "description": "\nEnables byte-range support\nfor both cached and uncached responses from the FastCGI server\nregardless of the “Accept-Ranges” field in these responses.\n"
        },
        {
          "name": "fastcgi_hide_header",
          "syntax": "fastcgi_hide_header field;",
          "context": "http, server, location",
          "description": "\nBy default,\nnginx does not pass the header fields “Status” and\n“X-Accel-...” from the response of a FastCGI\nserver to a client.\nThe fastcgi_hide_header directive sets additional fields\nthat will not be passed.\nIf, on the contrary, the passing of fields needs to be permitted,\nthe fastcgi_pass_header directive can be used.\n"
        },
        {
          "name": "fastcgi_ignore_client_abort",
          "syntax": "fastcgi_ignore_client_abort on | off;",
          "default": "fastcgi_ignore_client_abort off;",
          "context": "http, server, location",
          "description": "\nDetermines whether the connection with a FastCGI server should be\nclosed when a client closes the connection without waiting\nfor a response.\n"
        },
        {
          "name": "fastcgi_ignore_headers",
          "syntax": "fastcgi_ignore_headers field ...;",
          "context": "http, server, location",
          "description": "\nDisables processing of certain response header fields from the FastCGI server.\nThe following fields can be ignored: “X-Accel-Redirect”,\n“X-Accel-Expires”, “X-Accel-Limit-Rate” (1.1.6),\n“X-Accel-Buffering” (1.1.6),\n“X-Accel-Charset” (1.1.6), “Expires”,\n“Cache-Control”, “Set-Cookie” (0.8.44),\nand “Vary” (1.7.7).\n\n\nIf not disabled, processing of these header fields has the following\neffect:\n\n\n\n\n“X-Accel-Expires”, “Expires”,\n“Cache-Control”, “Set-Cookie”,\nand “Vary”\nset the parameters of response caching;\n\n\n\n“X-Accel-Redirect” performs an\ninternal\nredirect to the specified URI;\n\n\n\n“X-Accel-Limit-Rate” sets the\nrate\nlimit for transmission of a response to a client;\n\n\n\n“X-Accel-Buffering” enables or disables\nbuffering of a response;\n\n\n\n“X-Accel-Charset” sets the desired\ncharset\nof a response.\n\n\n\n \n"
        },
        {
          "name": "fastcgi_index",
          "syntax": "fastcgi_index name;",
          "context": "http, server, location",
          "description": "\nSets a file name that will be appended after a URI that ends with\na slash, in the value of the $fastcgi_script_name variable.\nFor example, with these settings\n\nfastcgi_index index.php;\nfastcgi_param SCRIPT_FILENAME /home/www/scripts/php$fastcgi_script_name;\n\n \nand the “/page.php” request,\nthe SCRIPT_FILENAME parameter will be equal to\n“/home/www/scripts/php/page.php”,\nand with the “/” request it will be equal to\n“/home/www/scripts/php/index.php”.\n"
        },
        {
          "name": "fastcgi_intercept_errors",
          "syntax": "fastcgi_intercept_errors on | off;",
          "default": "fastcgi_intercept_errors off;",
          "context": "http, server, location",
          "description": "\nDetermines whether FastCGI server responses with codes greater than or equal\nto 300 should be passed to a client\nor be intercepted and redirected to nginx for processing\nwith the error_page directive.\n"
        },
        {
          "name": "fastcgi_keep_conn",
          "syntax": "fastcgi_keep_conn on | off;",
          "default": "fastcgi_keep_conn off;",
          "context": "http, server, location",
          "description": "\nBy default, a FastCGI server will close a connection right after\nsending the response.\nHowever, when this directive is set to the value on,\nnginx will instruct a FastCGI server to keep connections open.\nThis is necessary, in particular, for\nkeepalive\nconnections to FastCGI servers to function.\n"
        },
        {
          "name": "fastcgi_limit_rate",
          "syntax": "fastcgi_limit_rate rate;",
          "default": "fastcgi_limit_rate 0;",
          "context": "http, server, location",
          "description": "\nLimits the speed of reading the response from the FastCGI server.\nThe rate is specified in bytes per second.\nThe zero value disables rate limiting.\nThe limit is set per a request, and so if nginx simultaneously opens\ntwo connections to the FastCFI server,\nthe overall rate will be twice as much as the specified limit.\nThe limitation works only if\nbuffering of responses from the FastCGI\nserver is enabled.\n"
        },
        {
          "name": "fastcgi_max_temp_file_size",
          "syntax": "fastcgi_max_temp_file_size size;",
          "default": "fastcgi_max_temp_file_size 1024m;",
          "context": "http, server, location",
          "description": "\nWhen buffering of responses from the FastCGI\nserver is enabled, and the whole response does not fit into the buffers\nset by the fastcgi_buffer_size and fastcgi_buffers\ndirectives, a part of the response can be saved to a temporary file.\nThis directive sets the maximum size of the temporary file.\nThe size of data written to the temporary file at a time is set\nby the fastcgi_temp_file_write_size directive.\n\n\nThe zero value disables buffering of responses to temporary files.\n\n\n\n\nThis restriction does not apply to responses\nthat will be cached\nor stored on disk.\n\n \n"
        },
        {
          "name": "fastcgi_next_upstream",
          "syntax": "fastcgi_next_upstream error | timeout | invalid_header | http_500 | http_503 | http_403 | http_404 | http_429 | non_idempotent | off ...;",
          "default": "fastcgi_next_upstream error timeout;",
          "context": "http, server, location",
          "description": "\nSpecifies in which cases a request should be passed to the next server:\n\n\n\nerror\nan error occurred while establishing a connection with the\nserver, passing a request to it, or reading the response header;\n\ntimeout\na timeout has occurred while establishing a connection with the\nserver, passing a request to it, or reading the response header;\n\ninvalid_header\na server returned an empty or invalid response;\n\nhttp_500\na server returned a response with the code 500;\n\nhttp_503\na server returned a response with the code 503;\n\nhttp_403\na server returned a response with the code 403;\n\nhttp_404\na server returned a response with the code 404;\n\nhttp_429\na server returned a response with the code 429 (1.11.13);\n\nnon_idempotent\nnormally, requests with a\nnon-idempotent\nmethod\n(POST, LOCK, PATCH)\nare not passed to the next server\nif a request has been sent to an upstream server (1.9.13);\nenabling this option explicitly allows retrying such requests;\n\n\noff\ndisables passing a request to the next server.\n\n\n \n\n\nOne should bear in mind that passing a request to the next server is\nonly possible if nothing has been sent to a client yet.\nThat is, if an error or timeout occurs in the middle of the\ntransferring of a response, fixing this is impossible.\n\n\nThe directive also defines what is considered an\nunsuccessful\nattempt of communication with a server.\nThe cases of error, timeout and\ninvalid_header are always considered unsuccessful attempts,\neven if they are not specified in the directive.\nThe cases of http_500, http_503,\nand http_429 are\nconsidered unsuccessful attempts only if they are specified in the directive.\nThe cases of http_403 and http_404\nare never considered unsuccessful attempts.\n\n\nPassing a request to the next server can be limited by\nthe number of tries\nand by time.\n"
        },
        {
          "name": "fastcgi_next_upstream_timeout",
          "syntax": "fastcgi_next_upstream_timeout time;",
          "default": "fastcgi_next_upstream_timeout 0;",
          "context": "http, server, location",
          "description": "\nLimits the time during which a request can be passed to the\nnext server.\nThe 0 value turns off this limitation.\n"
        },
        {
          "name": "fastcgi_next_upstream_tries",
          "syntax": "fastcgi_next_upstream_tries number;",
          "default": "fastcgi_next_upstream_tries 0;",
          "context": "http, server, location",
          "description": "\nLimits the number of possible tries for passing a request to the\nnext server.\nThe 0 value turns off this limitation.\n"
        },
        {
          "name": "fastcgi_no_cache",
          "syntax": "fastcgi_no_cache string ...;",
          "context": "http, server, location",
          "description": "\nDefines conditions under which the response will not be saved to a cache.\nIf at least one value of the string parameters is not empty and is not\nequal to “0” then the response will not be saved:\n\nfastcgi_no_cache $cookie_nocache $arg_nocache$arg_comment;\nfastcgi_no_cache $http_pragma    $http_authorization;\n\n \nCan be used along with the fastcgi_cache_bypass directive.\n"
        },
        {
          "name": "fastcgi_param",
          "syntax": "fastcgi_param parameter value [if_not_empty];",
          "context": "http, server, location",
          "description": "\nSets a parameter that should be passed to the FastCGI server.\nThe value can contain text, variables, and their combination.\nThese directives are inherited from the previous level if and\nonly if there are no\nfastcgi_param\ndirectives defined on the current level.\n\n\nThe following example shows the minimum required settings for PHP:\n\nfastcgi_param SCRIPT_FILENAME /home/www/scripts/php$fastcgi_script_name;\nfastcgi_param QUERY_STRING    $query_string;\n\n \n\n\nThe SCRIPT_FILENAME parameter is used in PHP for\ndetermining the script name, and the QUERY_STRING\nparameter is used to pass request parameters.\n\n\nFor scripts that process POST requests, the\nfollowing three parameters are also required:\n\nfastcgi_param REQUEST_METHOD  $request_method;\nfastcgi_param CONTENT_TYPE    $content_type;\nfastcgi_param CONTENT_LENGTH  $content_length;\n\n \n\n\nIf PHP was built with the --enable-force-cgi-redirect\nconfiguration parameter, the REDIRECT_STATUS parameter\nshould also be passed with the value “200”:\n\nfastcgi_param REDIRECT_STATUS 200;\n\n \n\n\nIf the directive is specified with if_not_empty (1.1.11) then\nsuch a parameter will be passed to the server only if its value is not empty:\n\nfastcgi_param HTTPS           $https if_not_empty;\n\n \n"
        },
        {
          "name": "fastcgi_pass",
          "syntax": "fastcgi_pass address;",
          "context": "location, if in location",
          "description": "\nSets the address of a FastCGI server.\nThe address can be specified as a domain name or IP address,\nand a port:\n\nfastcgi_pass localhost:9000;\n\n \nor as a UNIX-domain socket path:\n\nfastcgi_pass unix:/tmp/fastcgi.socket;\n\n \n\n\nIf a domain name resolves to several addresses, all of them will be\nused in a round-robin fashion.\nIn addition, an address can be specified as a\nserver group.\n\n\nParameter value can contain variables.\nIn this case, if an address is specified as a domain name,\nthe name is searched among the described\nserver groups,\nand, if not found, is determined using a\nresolver.\n"
        },
        {
          "name": "fastcgi_pass_header",
          "syntax": "fastcgi_pass_header field;",
          "context": "http, server, location",
          "description": "\nPermits passing otherwise disabled header\nfields from a FastCGI server to a client.\n"
        },
        {
          "name": "fastcgi_pass_request_body",
          "syntax": "fastcgi_pass_request_body on | off;",
          "default": "fastcgi_pass_request_body on;",
          "context": "http, server, location",
          "description": "\nIndicates whether the original request body is passed\nto the FastCGI server.\nSee also the fastcgi_pass_request_headers directive.\n"
        },
        {
          "name": "fastcgi_pass_request_headers",
          "syntax": "fastcgi_pass_request_headers on | off;",
          "default": "fastcgi_pass_request_headers on;",
          "context": "http, server, location",
          "description": "\nIndicates whether the header fields of the original request are passed\nto the FastCGI server.\nSee also the fastcgi_pass_request_body directive.\n"
        },
        {
          "name": "fastcgi_read_timeout",
          "syntax": "fastcgi_read_timeout time;",
          "default": "fastcgi_read_timeout 60s;",
          "context": "http, server, location",
          "description": "\nDefines a timeout for reading a response from the FastCGI server.\nThe timeout is set only between two successive read operations,\nnot for the transmission of the whole response.\nIf the FastCGI server does not transmit anything within this time,\nthe connection is closed.\n"
        },
        {
          "name": "fastcgi_request_buffering",
          "syntax": "fastcgi_request_buffering on | off;",
          "default": "fastcgi_request_buffering on;",
          "context": "http, server, location",
          "description": "\nEnables or disables buffering of a client request body.\n\n\nWhen buffering is enabled, the entire request body is\nread\nfrom the client before sending the request to a FastCGI server.\n\n\nWhen buffering is disabled, the request body is sent to the FastCGI server\nimmediately as it is received.\nIn this case, the request cannot be passed to the\nnext server\nif nginx already started sending the request body.\n"
        },
        {
          "name": "fastcgi_send_lowat",
          "syntax": "fastcgi_send_lowat size;",
          "default": "fastcgi_send_lowat 0;",
          "context": "http, server, location",
          "description": "\nIf the directive is set to a non-zero value, nginx will try to\nminimize the number\nof send operations on outgoing connections to a FastCGI server by using either\nNOTE_LOWAT flag of the\nkqueue method,\nor the SO_SNDLOWAT socket option,\nwith the specified size.\n\n\nThis directive is ignored on Linux, Solaris, and Windows.\n"
        },
        {
          "name": "fastcgi_send_timeout",
          "syntax": "fastcgi_send_timeout time;",
          "default": "fastcgi_send_timeout 60s;",
          "context": "http, server, location",
          "description": "\nSets a timeout for transmitting a request to the FastCGI server.\nThe timeout is set only between two successive write operations,\nnot for the transmission of the whole request.\nIf the FastCGI server does not receive anything within this time,\nthe connection is closed.\n"
        },
        {
          "name": "fastcgi_socket_keepalive",
          "syntax": "fastcgi_socket_keepalive on | off;",
          "default": "fastcgi_socket_keepalive off;",
          "context": "http, server, location",
          "description": "\nConfigures the “TCP keepalive” behavior\nfor outgoing connections to a FastCGI server.\nBy default, the operating system’s settings are in effect for the socket.\nIf the directive is set to the value “on”, the\nSO_KEEPALIVE socket option is turned on for the socket.\n"
        },
        {
          "name": "fastcgi_split_path_info",
          "syntax": "fastcgi_split_path_info regex;",
          "context": "location",
          "description": "\nDefines a regular expression that captures a value for the\n$fastcgi_path_info variable.\nThe regular expression should have two captures: the first becomes\na value of the $fastcgi_script_name variable, the second\nbecomes a value of the $fastcgi_path_info variable.\nFor example, with these settings\n\nlocation ~ ^(.+\\.php)(.*)$ {\n    fastcgi_split_path_info       ^(.+\\.php)(.*)$;\n    fastcgi_param SCRIPT_FILENAME /path/to/php$fastcgi_script_name;\n    fastcgi_param PATH_INFO       $fastcgi_path_info;\n\n \nand the “/show.php/article/0001” request,\nthe SCRIPT_FILENAME parameter will be equal to\n“/path/to/php/show.php”, and the\nPATH_INFO parameter will be equal to\n“/article/0001”.\n"
        },
        {
          "name": "fastcgi_store",
          "syntax": "fastcgi_store on | off | string;",
          "default": "fastcgi_store off;",
          "context": "http, server, location",
          "description": "\nEnables saving of files to a disk.\nThe on parameter saves files with paths\ncorresponding to the directives\nalias or\nroot.\nThe off parameter disables saving of files.\nIn addition, the file name can be set explicitly using the\nstring with variables:\n\nfastcgi_store /data/www$original_uri;\n\n \n\n\nThe modification time of files is set according to the received\n“Last-Modified” response header field.\nThe response is first written to a temporary file,\nand then the file is renamed.\nStarting from version 0.8.9, temporary files and the persistent store\ncan be put on different file systems.\nHowever, be aware that in this case a file is copied\nacross two file systems instead of the cheap renaming operation.\nIt is thus recommended that for any given location both saved files and a\ndirectory holding temporary files, set by the fastcgi_temp_path\ndirective, are put on the same file system.\n\n\nThis directive can be used to create local copies of static unchangeable\nfiles, e.g.:\n\nlocation /images/ {\n    root                 /data/www;\n    error_page           404 = /fetch$uri;\n}\n\nlocation /fetch/ {\n    internal;\n\n    fastcgi_pass         backend:9000;\n    ...\n\n    fastcgi_store        on;\n    fastcgi_store_access user:rw group:rw all:r;\n    fastcgi_temp_path    /data/temp;\n\n    alias                /data/www/;\n}\n\n \n"
        },
        {
          "name": "fastcgi_store_access",
          "syntax": "fastcgi_store_access users:permissions ...;",
          "default": "fastcgi_store_access user:rw;",
          "context": "http, server, location",
          "description": "\nSets access permissions for newly created files and directories, e.g.:\n\nfastcgi_store_access user:rw group:rw all:r;\n\n \n\n\nIf any group or all access permissions\nare specified then user permissions may be omitted:\n\nfastcgi_store_access group:rw all:r;\n\n \n"
        },
        {
          "name": "fastcgi_temp_file_write_size",
          "syntax": "fastcgi_temp_file_write_size size;",
          "default": "fastcgi_temp_file_write_size 8k|16k;",
          "context": "http, server, location",
          "description": "\nLimits the size of data written to a temporary file\nat a time, when buffering of responses from the FastCGI server\nto temporary files is enabled.\nBy default, size is limited by two buffers set by the\nfastcgi_buffer_size and fastcgi_buffers directives.\nThe maximum size of a temporary file is set by the\nfastcgi_max_temp_file_size directive.\n"
        },
        {
          "name": "fastcgi_temp_path",
          "syntax": "fastcgi_temp_path path [level1 [level2 [level3]]];",
          "default": "fastcgi_temp_path fastcgi_temp;",
          "context": "http, server, location",
          "description": "\nDefines a directory for storing temporary files\nwith data received from FastCGI servers.\nUp to three-level subdirectory hierarchy can be used underneath the specified\ndirectory.\nFor example, in the following configuration\n\nfastcgi_temp_path /spool/nginx/fastcgi_temp 1 2;\n\n \na temporary file might look like this:\n\n/spool/nginx/fastcgi_temp/7/45/00000123457\n\n \n\n\nSee also the use_temp_path parameter of the\nfastcgi_cache_path directive.\n"
        }
      ]
    },
    {
      "name": "ngx_http_geo_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_geo_module.html",
      "directives": [
        {
          "name": "geo",
          "syntax": "geo [$address] $variable { ... }",
          "context": "http",
          "description": "\nDescribes the dependency of values of the specified variable\non the client IP address.\nBy default, the address is taken from the $remote_addr variable,\nbut it can also be taken from another variable (0.7.27), for example:\n\ngeo $arg_remote_addr $geo {\n    ...;\n}\n\n \n\n\n\n\nSince variables are evaluated only when used, the mere existence\nof even a large number of declared “geo” variables\ndoes not cause any extra costs for request processing.\n\n \n\n\nIf the value of a variable does not represent a valid IP address\nthen the “255.255.255.255” address is used.\n\n\nAddresses are specified either as prefixes in CIDR notation\n(including individual addresses) or as ranges (0.7.23).\n\n\nIPv6 prefixes are supported starting from versions 1.3.10 and 1.2.7.\n\n \n\n\nThe following special parameters are also supported:\n\n\n\ndelete\n\ndeletes the specified network (0.7.23).\n\n\ndefault\n\na value set to the variable if the client address does not\nmatch any of the specified addresses.\nWhen addresses are specified in CIDR notation,\n“0.0.0.0/0” and “::/0”\ncan be used instead of default.\nWhen default is not specified, the default\nvalue will be an empty string.\n\n\ninclude\n\nincludes a file with addresses and values.\nThere can be several inclusions.\n\n\nproxy\n\ndefines trusted addresses (0.8.7, 0.7.63).\nWhen a request comes from a trusted address,\nan address from the “X-Forwarded-For” request\nheader field will be used instead.\nIn contrast to the regular addresses, trusted addresses are\nchecked sequentially.\n\nTrusted IPv6 addresses are supported starting from versions 1.3.0 and 1.2.1.\n\n\n\nproxy_recursive\n\nenables recursive address search (1.3.0, 1.2.1).\nIf recursive search is disabled then instead of the original client\naddress that matches one of the trusted addresses, the last\naddress sent in “X-Forwarded-For” will be used.\nIf recursive search is enabled then instead of the original client\naddress that matches one of the trusted addresses, the last\nnon-trusted address sent in “X-Forwarded-For” will be used.\n\n\nranges\n\nindicates that addresses are specified as ranges (0.7.23).\nThis parameter should be the first.\nTo speed up loading of a geo base, addresses should be put in ascending order.\n\n\n\n \n\n\nExample:\n\ngeo $country {\n    default        ZZ;\n    include        conf/geo.conf;\n    delete         127.0.0.0/16;\n    proxy          192.168.100.0/24;\n    proxy          2001:0db8::/32;\n\n    127.0.0.0/24   US;\n    127.0.0.1/32   RU;\n    10.1.0.0/16    RU;\n    192.168.1.0/24 UK;\n}\n\n \n\n\nThe conf/geo.conf file could contain the following lines:\n\n10.2.0.0/16    RU;\n192.168.2.0/24 RU;\n\n \n\n\nA value of the most specific match is used.\nFor example, for the 127.0.0.1 address the value “RU”\nwill be chosen, not “US”.\n\n\nExample with ranges:\n\ngeo $country {\n    ranges;\n    default                   ZZ;\n    127.0.0.0-127.0.0.0       US;\n    127.0.0.1-127.0.0.1       RU;\n    127.0.0.1-127.0.0.255     US;\n    10.1.0.0-10.1.255.255     RU;\n    192.168.1.0-192.168.1.255 UK;\n}\n\n \n"
        }
      ]
    },
    {
      "name": "ngx_http_geoip_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_geoip_module.html",
      "directives": [
        {
          "name": "geoip_country",
          "syntax": "geoip_country file;",
          "context": "http",
          "description": "\nSpecifies a database used to determine the country\ndepending on the client IP address.\nThe following variables are available when using this database:\n\n\n\n$geoip_country_code\n\ntwo-letter country code, for example,\n“RU”, “US”.\n\n\n$geoip_country_code3\n\n\nthree-letter country code, for example,\n“RUS”, “USA”.\n\n\n$geoip_country_name\n\ncountry name, for example,\n“Russian Federation”, “United States”.\n\n\n\n \n"
        },
        {
          "name": "geoip_city",
          "syntax": "geoip_city file;",
          "context": "http",
          "description": "\nSpecifies a database used to determine the country, region, and city\ndepending on the client IP address.\nThe following variables are available when using this database:\n\n\n\n$geoip_area_code\ntelephone area code (US only).\n\nThis variable may contain outdated information since\nthe corresponding database field is deprecated.\n\n\n\n\n$geoip_city_continent_code\ntwo-letter continent code, for example,\n“EU”, “NA”.\n\n\n$geoip_city_country_code\n\n\ntwo-letter country code, for example,\n“RU”, “US”.\n\n\n$geoip_city_country_code3\n\n\nthree-letter country code, for example,\n“RUS”, “USA”.\n\n\n$geoip_city_country_name\n\n\ncountry name, for example,\n“Russian Federation”, “United States”.\n\n\n$geoip_dma_code\n\nDMA region code in US (also known as “metro code”), according to the\ngeotargeting\nin Google AdWords API.\n\n\n$geoip_latitude\nlatitude.\n\n$geoip_longitude\nlongitude.\n\n$geoip_region\n\ntwo-symbol country region code (region, territory, state, province, federal land\nand the like), for example,\n“48”, “DC”.\n\n\n$geoip_region_name\n\ncountry region name (region, territory, state, province, federal land\nand the like), for example,\n“Moscow City”, “District of Columbia”.\n\n\n$geoip_city\n\ncity name, for example,\n“Moscow”, “Washington”.\n\n\n$geoip_postal_code\n\npostal code.\n\n\n\n \n"
        },
        {
          "name": "geoip_org",
          "syntax": "geoip_org file;",
          "context": "http",
          "description": "\nSpecifies a database used to determine the organization\ndepending on the client IP address.\nThe following variable is available when using this database:\n\n\n\n$geoip_org\n\norganization name, for example, “The University of Melbourne”.\n\n\n\n \n"
        },
        {
          "name": "geoip_proxy",
          "syntax": "geoip_proxy address | CIDR;",
          "context": "http",
          "description": "\nDefines trusted addresses.\nWhen a request comes from a trusted address,\nan address from the “X-Forwarded-For” request\nheader field will be used instead.\n"
        },
        {
          "name": "geoip_proxy_recursive",
          "syntax": "geoip_proxy_recursive on | off;",
          "default": "geoip_proxy_recursive off;",
          "context": "http",
          "description": "\nIf recursive search is disabled then instead of the original client\naddress that matches one of the trusted addresses, the last\naddress sent in “X-Forwarded-For” will be used.\nIf recursive search is enabled then instead of the original client\naddress that matches one of the trusted addresses, the last\nnon-trusted address sent in “X-Forwarded-For” will be used.\n"
        }
      ]
    },
    {
      "name": "ngx_http_grpc_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_grpc_module.html",
      "directives": [
        {
          "name": "grpc_bind",
          "syntax": "grpc_bind address [transparent ] | off;",
          "context": "http, server, location",
          "description": "\nMakes outgoing connections to a gRPC server originate\nfrom the specified local IP address with an optional port.\nParameter value can contain variables.\nThe special value off cancels the effect\nof the grpc_bind directive\ninherited from the previous configuration level, which allows the\nsystem to auto-assign the local IP address and port.\n"
        },
        {
          "name": "grpc_buffer_size",
          "syntax": "grpc_buffer_size size;",
          "default": "grpc_buffer_size 4k|8k;",
          "context": "http, server, location",
          "description": "\nSets the size of the buffer used for reading the response\nreceived from the gRPC server.\nThe response is passed to the client synchronously, as soon as it is received.\n"
        },
        {
          "name": "grpc_connect_timeout",
          "syntax": "grpc_connect_timeout time;",
          "default": "grpc_connect_timeout 60s;",
          "context": "http, server, location",
          "description": "\nDefines a timeout for establishing a connection with a gRPC server.\nIt should be noted that this timeout cannot usually exceed 75 seconds.\n"
        },
        {
          "name": "grpc_hide_header",
          "syntax": "grpc_hide_header field;",
          "context": "http, server, location",
          "description": "\nBy default,\nnginx does not pass the header fields “Date”,\n“Server”, and\n“X-Accel-...” from the response of a gRPC\nserver to a client.\nThe grpc_hide_header directive sets additional fields\nthat will not be passed.\nIf, on the contrary, the passing of fields needs to be permitted,\nthe grpc_pass_header directive can be used.\n"
        },
        {
          "name": "grpc_ignore_headers",
          "syntax": "grpc_ignore_headers field ...;",
          "context": "http, server, location",
          "description": "\nDisables processing of certain response header fields from the gRPC server.\nThe following fields can be ignored: “X-Accel-Redirect”\nand “X-Accel-Charset”.\n\n\nIf not disabled, processing of these header fields has the following\neffect:\n\n\n\n\n“X-Accel-Redirect” performs an\ninternal\nredirect to the specified URI;\n\n\n\n“X-Accel-Charset” sets the desired\ncharset\nof a response.\n\n\n\n \n"
        },
        {
          "name": "grpc_intercept_errors",
          "syntax": "grpc_intercept_errors on | off;",
          "default": "grpc_intercept_errors off;",
          "context": "http, server, location",
          "description": "\nDetermines whether gRPC server responses with codes greater than or equal\nto 300 should be passed to a client\nor be intercepted and redirected to nginx for processing\nwith the error_page directive.\n"
        },
        {
          "name": "grpc_next_upstream",
          "syntax": "grpc_next_upstream error | timeout | invalid_header | http_500 | http_502 | http_503 | http_504 | http_403 | http_404 | http_429 | non_idempotent | off ...;",
          "default": "grpc_next_upstream error timeout;",
          "context": "http, server, location",
          "description": "\nSpecifies in which cases a request should be passed to the next server:\n\n\n\nerror\nan error occurred while establishing a connection with the\nserver, passing a request to it, or reading the response header;\n\ntimeout\na timeout has occurred while establishing a connection with the\nserver, passing a request to it, or reading the response header;\n\ninvalid_header\na server returned an empty or invalid response;\n\nhttp_500\na server returned a response with the code 500;\n\nhttp_502\na server returned a response with the code 502;\n\nhttp_503\na server returned a response with the code 503;\n\nhttp_504\na server returned a response with the code 504;\n\nhttp_403\na server returned a response with the code 403;\n\nhttp_404\na server returned a response with the code 404;\n\nhttp_429\na server returned a response with the code 429;\n\nnon_idempotent\nnormally, requests with a\nnon-idempotent\nmethod\n(POST, LOCK, PATCH)\nare not passed to the next server\nif a request has been sent to an upstream server;\nenabling this option explicitly allows retrying such requests;\n\n\noff\ndisables passing a request to the next server.\n\n\n \n\n\nOne should bear in mind that passing a request to the next server is\nonly possible if nothing has been sent to a client yet.\nThat is, if an error or timeout occurs in the middle of the\ntransferring of a response, fixing this is impossible.\n\n\nThe directive also defines what is considered an\nunsuccessful\nattempt of communication with a server.\nThe cases of error, timeout and\ninvalid_header are always considered unsuccessful attempts,\neven if they are not specified in the directive.\nThe cases of http_500, http_502,\nhttp_503, http_504,\nand http_429 are\nconsidered unsuccessful attempts only if they are specified in the directive.\nThe cases of http_403 and http_404\nare never considered unsuccessful attempts.\n\n\nPassing a request to the next server can be limited by\nthe number of tries\nand by time.\n"
        },
        {
          "name": "grpc_next_upstream_timeout",
          "syntax": "grpc_next_upstream_timeout time;",
          "default": "grpc_next_upstream_timeout 0;",
          "context": "http, server, location",
          "description": "\nLimits the time during which a request can be passed to the\nnext server.\nThe 0 value turns off this limitation.\n"
        },
        {
          "name": "grpc_next_upstream_tries",
          "syntax": "grpc_next_upstream_tries number;",
          "default": "grpc_next_upstream_tries 0;",
          "context": "http, server, location",
          "description": "\nLimits the number of possible tries for passing a request to the\nnext server.\nThe 0 value turns off this limitation.\n"
        },
        {
          "name": "grpc_pass",
          "syntax": "grpc_pass address;",
          "context": "location, if in location",
          "description": "\nSets the gRPC server address.\nThe address can be specified as a domain name or IP address,\nand a port:\n\ngrpc_pass localhost:9000;\n\n \nor as a UNIX-domain socket path:\n\ngrpc_pass unix:/tmp/grpc.socket;\n\n \nAlternatively, the “grpc://” scheme can be used:\n\ngrpc_pass grpc://127.0.0.1:9000;\n\n \nTo use gRPC over SSL, the “grpcs://” scheme should be used:\n\ngrpc_pass grpcs://127.0.0.1:443;\n\n \n\n\nIf a domain name resolves to several addresses, all of them will be\nused in a round-robin fashion.\nIn addition, an address can be specified as a\nserver group.\n"
        },
        {
          "name": "grpc_pass_header",
          "syntax": "grpc_pass_header field;",
          "context": "http, server, location",
          "description": "\nPermits passing otherwise disabled header\nfields from a gRPC server to a client.\n"
        },
        {
          "name": "grpc_read_timeout",
          "syntax": "grpc_read_timeout time;",
          "default": "grpc_read_timeout 60s;",
          "context": "http, server, location",
          "description": "\nDefines a timeout for reading a response from the gRPC server.\nThe timeout is set only between two successive read operations,\nnot for the transmission of the whole response.\nIf the gRPC server does not transmit anything within this time,\nthe connection is closed.\n"
        },
        {
          "name": "grpc_send_timeout",
          "syntax": "grpc_send_timeout time;",
          "default": "grpc_send_timeout 60s;",
          "context": "http, server, location",
          "description": "\nSets a timeout for transmitting a request to the gRPC server.\nThe timeout is set only between two successive write operations,\nnot for the transmission of the whole request.\nIf the gRPC server does not receive anything within this time,\nthe connection is closed.\n"
        },
        {
          "name": "grpc_set_header",
          "syntax": "grpc_set_header field value;",
          "default": "grpc_set_header Content-Length $content_length;",
          "context": "http, server, location",
          "description": "\nAllows redefining or appending fields to the request header\npassed to the gRPC server.\nThe value can contain text, variables, and their combinations.\nThese directives are inherited from the previous level if and\nonly if there are no\ngrpc_set_header\ndirectives defined on the current level.\n\n\nIf the value of a header field is an empty string then this\nfield will not be passed to a gRPC server:\n\ngrpc_set_header Accept-Encoding \"\";\n\n \n"
        },
        {
          "name": "grpc_socket_keepalive",
          "syntax": "grpc_socket_keepalive on | off;",
          "default": "grpc_socket_keepalive off;",
          "context": "http, server, location",
          "description": "\nConfigures the “TCP keepalive” behavior\nfor outgoing connections to a gRPC server.\nBy default, the operating system’s settings are in effect for the socket.\nIf the directive is set to the value “on”, the\nSO_KEEPALIVE socket option is turned on for the socket.\n"
        },
        {
          "name": "grpc_ssl_certificate",
          "syntax": "grpc_ssl_certificate file;",
          "context": "http, server, location",
          "description": "\nSpecifies a file with the certificate in the PEM format\nused for authentication to a gRPC SSL server.\n"
        },
        {
          "name": "grpc_ssl_certificate_key",
          "syntax": "grpc_ssl_certificate_key file;",
          "context": "http, server, location",
          "description": "\nSpecifies a file with the secret key in the PEM format\nused for authentication to a gRPC SSL server.\n\n\nThe value\nengine:name:id\ncan be specified instead of the file,\nwhich loads a secret key with a specified id\nfrom the OpenSSL engine name.\n"
        },
        {
          "name": "grpc_ssl_ciphers",
          "syntax": "grpc_ssl_ciphers ciphers;",
          "default": "grpc_ssl_ciphers DEFAULT;",
          "context": "http, server, location",
          "description": "\nSpecifies the enabled ciphers for requests to a gRPC SSL server.\nThe ciphers are specified in the format understood by the OpenSSL library.\n\n\nThe full list can be viewed using the\n“openssl ciphers” command.\n"
        },
        {
          "name": "grpc_ssl_crl",
          "syntax": "grpc_ssl_crl file;",
          "context": "http, server, location",
          "description": "\nSpecifies a file with revoked certificates (CRL)\nin the PEM format used to verify\nthe certificate of the gRPC SSL server.\n"
        },
        {
          "name": "grpc_ssl_name",
          "syntax": "grpc_ssl_name name;",
          "default": "grpc_ssl_name host from grpc_pass;",
          "context": "http, server, location",
          "description": "\nAllows overriding the server name used to\nverify\nthe certificate of the gRPC SSL server and to be\npassed through SNI\nwhen establishing a connection with the gRPC SSL server.\n\n\nBy default, the host part from grpc_pass is used.\n"
        },
        {
          "name": "grpc_ssl_password_file",
          "syntax": "grpc_ssl_password_file file;",
          "context": "http, server, location",
          "description": "\nSpecifies a file with passphrases for\nsecret keys\nwhere each passphrase is specified on a separate line.\nPassphrases are tried in turn when loading the key.\n"
        },
        {
          "name": "grpc_ssl_protocols",
          "syntax": "grpc_ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2] [TLSv1.3];",
          "default": "grpc_ssl_protocols TLSv1 TLSv1.1 TLSv1.2;",
          "context": "http, server, location",
          "description": "\nEnables the specified protocols for requests to a gRPC SSL server.\n"
        },
        {
          "name": "grpc_ssl_server_name",
          "syntax": "grpc_ssl_server_name on | off;",
          "default": "grpc_ssl_server_name off;",
          "context": "http, server, location",
          "description": "\nEnables or disables passing of the server name through\nTLS\nServer Name Indication extension (SNI, RFC 6066)\nwhen establishing a connection with the gRPC SSL server.\n"
        },
        {
          "name": "grpc_ssl_session_reuse",
          "syntax": "grpc_ssl_session_reuse on | off;",
          "default": "grpc_ssl_session_reuse on;",
          "context": "http, server, location",
          "description": "\nDetermines whether SSL sessions can be reused when working with\nthe gRPC server.\nIf the errors\n“SSL3_GET_FINISHED:digest check failed”\nappear in the logs, try disabling session reuse.\n"
        },
        {
          "name": "grpc_ssl_trusted_certificate",
          "syntax": "grpc_ssl_trusted_certificate file;",
          "context": "http, server, location",
          "description": "\nSpecifies a file with trusted CA certificates in the PEM format\nused to verify\nthe certificate of the gRPC SSL server.\n"
        },
        {
          "name": "grpc_ssl_verify",
          "syntax": "grpc_ssl_verify on | off;",
          "default": "grpc_ssl_verify off;",
          "context": "http, server, location",
          "description": "\nEnables or disables verification of the gRPC SSL server certificate.\n"
        },
        {
          "name": "grpc_ssl_verify_depth",
          "syntax": "grpc_ssl_verify_depth number;",
          "default": "grpc_ssl_verify_depth 1;",
          "context": "http, server, location",
          "description": "\nSets the verification depth in the gRPC SSL server certificates chain.\n"
        }
      ]
    },
    {
      "name": "ngx_http_gunzip_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_gunzip_module.html",
      "directives": [
        {
          "name": "gunzip",
          "syntax": "gunzip on | off;",
          "default": "gunzip off;",
          "context": "http, server, location",
          "description": "\nEnables or disables decompression of gzipped responses\nfor clients that lack gzip support.\nIf enabled, the following directives are also taken into account\nwhen determining if clients support gzip:\ngzip_http_version,\ngzip_proxied, and\ngzip_disable.\nSee also the gzip_vary directive.\n"
        },
        {
          "name": "gunzip_buffers",
          "syntax": "gunzip_buffers number size;",
          "default": "gunzip_buffers 32 4k|16 8k;",
          "context": "http, server, location",
          "description": "\nSets the number and size of buffers\nused to decompress a response.\nBy default, the buffer size is equal to one memory page.\nThis is either 4K or 8K, depending on a platform.\n"
        }
      ]
    },
    {
      "name": "ngx_http_gzip_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_gzip_module.html",
      "directives": [
        {
          "name": "gzip",
          "syntax": "gzip on | off;",
          "default": "gzip off;",
          "context": "http, server, location, if in location",
          "description": "\nEnables or disables gzipping of responses.\n"
        },
        {
          "name": "gzip_buffers",
          "syntax": "gzip_buffers number size;",
          "default": "gzip_buffers 32 4k|16 8k;",
          "context": "http, server, location",
          "description": "\nSets the number and size of buffers\nused to compress a response.\nBy default, the buffer size is equal to one memory page.\nThis is either 4K or 8K, depending on a platform.\n\n\nUntil version 0.7.28, four 4K or 8K buffers were used by default.\n\n \n"
        },
        {
          "name": "gzip_comp_level",
          "syntax": "gzip_comp_level level;",
          "default": "gzip_comp_level 1;",
          "context": "http, server, location",
          "description": "\nSets a gzip compression level of a response.\nAcceptable values are in the range from 1 to 9.\n"
        },
        {
          "name": "gzip_disable",
          "syntax": "gzip_disable regex ...;",
          "context": "http, server, location",
          "description": "\nDisables gzipping of responses for requests with\n“User-Agent” header fields matching\nany of the specified regular expressions.\n\n\nThe special mask “msie6” (0.7.12) corresponds to\nthe regular expression “MSIE [4-6]\\.”, but works faster.\nStarting from version 0.8.11, “MSIE 6.0; ... SV1”\nis excluded from this mask.\n"
        },
        {
          "name": "gzip_http_version",
          "syntax": "gzip_http_version 1.0 | 1.1;",
          "default": "gzip_http_version 1.1;",
          "context": "http, server, location",
          "description": "\nSets the minimum HTTP version of a request required to compress a response.\n"
        },
        {
          "name": "gzip_min_length",
          "syntax": "gzip_min_length length;",
          "default": "gzip_min_length 20;",
          "context": "http, server, location",
          "description": "\nSets the minimum length of a response that will be gzipped.\nThe length is determined only from the “Content-Length”\nresponse header field.\n"
        },
        {
          "name": "gzip_proxied",
          "syntax": "gzip_proxied off | expired | no-cache | no-store | private | no_last_modified | no_etag | auth | any ...;",
          "default": "gzip_proxied off;",
          "context": "http, server, location",
          "description": "\nEnables or disables gzipping of responses for proxied\nrequests depending on the request and response.\nThe fact that the request is proxied is determined by\nthe presence of the “Via” request header field.\nThe directive accepts multiple parameters:\n\n\n\noff\n\ndisables compression for all proxied requests,\nignoring other parameters;\n\n\nexpired\n\nenables compression if a response header includes the\n“Expires” field with a value that disables caching;\n\n\nno-cache\n\nenables compression if a response header includes the\n“Cache-Control” field with the\n“no-cache” parameter;\n\n\nno-store\n\nenables compression if a response header includes the\n“Cache-Control” field with the\n“no-store” parameter;\n\n\nprivate\n\nenables compression if a response header includes the\n“Cache-Control” field with the\n“private” parameter;\n\n\nno_last_modified\n\nenables compression if a response header does not include the\n“Last-Modified” field;\n\n\nno_etag\n\nenables compression if a response header does not include the\n“ETag” field;\n\n\nauth\n\nenables compression if a request header includes the\n“Authorization” field;\n\n\nany\n\nenables compression for all proxied requests.\n\n\n\n \n"
        },
        {
          "name": "gzip_types",
          "syntax": "gzip_types mime-type ...;",
          "default": "gzip_types text/html;",
          "context": "http, server, location",
          "description": "\nEnables gzipping of responses for the specified MIME types in addition\nto “text/html”.\nThe special value “*” matches any MIME type (0.8.29).\nResponses with the “text/html” type are always compressed.\n"
        },
        {
          "name": "gzip_vary",
          "syntax": "gzip_vary on | off;",
          "default": "gzip_vary off;",
          "context": "http, server, location",
          "description": "\nEnables or disables inserting the “Vary: Accept-Encoding”\nresponse header field if the directives\ngzip,\ngzip_static, or\ngunzip\nare active.\n"
        }
      ]
    },
    {
      "name": "ngx_http_gzip_static_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_gzip_static_module.html",
      "directives": [
        {
          "name": "gzip_static",
          "syntax": "gzip_static on | off | always;",
          "default": "gzip_static off;",
          "context": "http, server, location",
          "description": "\nEnables (“on”) or disables (“off”)\nchecking the existence of precompressed files.\nThe following directives are also taken into account:\ngzip_http_version,\ngzip_proxied,\ngzip_disable,\nand gzip_vary.\n\n\nWith the “always” value (1.3.6), gzipped file is used\nin all cases, without checking if the client supports it.\nIt is useful if there are no uncompressed files on the disk anyway\nor the ngx_http_gunzip_module\nis used.\n\n\nThe files can be compressed using the gzip command,\nor any other compatible one.\nIt is recommended that the modification date and time of original and\ncompressed files be the same.\n"
        }
      ]
    },
    {
      "name": "ngx_http_headers_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_headers_module.html",
      "directives": [
        {
          "name": "add_header",
          "syntax": "add_header name value [always];",
          "context": "http, server, location, if in location",
          "description": "\nAdds the specified field to a response header provided that\nthe response code equals 200, 201 (1.3.10), 204, 206, 301, 302, 303, 304,\n307 (1.1.16, 1.0.13), or 308 (1.13.0).\nParameter value can contain variables.\n\n\nThere could be several add_header directives.\nThese directives are inherited from the previous level if and\nonly if there are no\nadd_header\ndirectives defined on the current level.\n\n\nIf the always parameter is specified (1.7.5),\nthe header field will be added regardless of the response code.\n"
        },
        {
          "name": "add_trailer",
          "syntax": "add_trailer name value [always];",
          "context": "http, server, location, if in location",
          "description": "\nAdds the specified field to the end of a response provided that\nthe response code equals 200, 201, 206, 301, 302, 303, 307, or 308.\nParameter value can contain variables.\n\n\nThere could be several add_trailer directives.\nThese directives are inherited from the previous level if and\nonly if there are no\nadd_trailer\ndirectives defined on the current level.\n\n\nIf the always parameter is specified\nthe specified field will be added regardless of the response code.\n"
        },
        {
          "name": "expires",
          "syntax": "expires [modified] time;expires epoch | max | off;",
          "default": "expires off;",
          "context": "http, server, location, if in location",
          "description": "\nEnables or disables adding or modifying the “Expires”\nand “Cache-Control” response header fields provided that\nthe response code equals 200, 201 (1.3.10), 204, 206, 301, 302, 303, 304,\n307 (1.1.16, 1.0.13), or 308 (1.13.0).\nThe parameter can be a positive or negative\ntime.\n\n\nThe time in the “Expires” field is computed as a sum of the\ncurrent time and time specified in the directive.\nIf the modified parameter is used (0.7.0, 0.6.32)\nthen the time is computed as a sum of the file’s modification time and\nthe time specified in the directive.\n\n\nIn addition, it is possible to specify a time of day using\nthe “@” prefix (0.7.9, 0.6.34):\n\nexpires @15h30m;\n\n \n\n\nThe contents of the “Cache-Control” field depends\non the sign of the specified time:\n\n\n\n\ntime is negative — “Cache-Control: no-cache”.\n\n\n\ntime is positive or zero —\n“Cache-Control: max-age=t”,\nwhere t is a time specified in the directive, in seconds.\n\n\n\n \n\n\nThe epoch parameter sets “Expires”\nto the value “Thu, 01 Jan 1970 00:00:01 GMT”,\nand “Cache-Control” to “no-cache”.\n\n\nThe max parameter sets “Expires”\nto the value “Thu, 31 Dec 2037 23:55:55 GMT”,\nand “Cache-Control” to 10 years.\n\n\nThe off parameter disables adding or modifying the\n“Expires” and “Cache-Control” response\nheader fields.\n\n\nThe last parameter value can contain variables (1.7.9):\n\nmap $sent_http_content_type $expires {\n    default         off;\n    application/pdf 42d;\n    ~image/         max;\n}\n\nexpires $expires;\n\n \n"
        }
      ]
    },
    {
      "name": "ngx_http_image_filter_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_image_filter_module.html",
      "directives": [
        {
          "name": "image_filter",
          "syntax": "image_filter off;image_filter test;image_filter size;image_filter rotate 90 | 180 | 270;image_filter resize width height;image_filter crop width height;",
          "default": "image_filter off;",
          "context": "location",
          "description": "\nSets the type of transformation to perform on images:\n\n\n\noff\n\nturns off module processing in a surrounding location.\n\n\ntest\n\nensures that responses are images in either JPEG, GIF, PNG, or WebP format.\nOtherwise, the\n415 (Unsupported Media Type)\nerror is returned.\n\n\nsize\n\noutputs information about images in a JSON format, e.g.:\n{ \"img\" : { \"width\": 100, \"height\": 100, \"type\": \"gif\" } }\n\nIn case of an error, the output is as follows:\n{}\n\n\n\nrotate\n90|180|270\n\n\nrotates images counter-clockwise by the specified number of degrees.\nParameter value can contain variables.\nThis mode can be used either alone or along with the\nresize and crop transformations.\n\n\nresize\nwidth\nheight\n\n\nproportionally reduces an image to the specified sizes.\nTo reduce by only one dimension, another dimension can be specified as\n“-”.\nIn case of an error, the server will return code\n415 (Unsupported Media Type).\nParameter values can contain variables.\nWhen used along with the rotate parameter,\nthe rotation happens after reduction.\n\n\ncrop\nwidth\nheight\n\n\nproportionally reduces an image to the larger side size\nand crops extraneous edges by another side.\nTo reduce by only one dimension, another dimension can be specified as\n“-”.\nIn case of an error, the server will return code\n415 (Unsupported Media Type).\nParameter values can contain variables.\nWhen used along with the rotate parameter,\nthe rotation happens before reduction.\n\n\n\n \n"
        },
        {
          "name": "image_filter_buffer",
          "syntax": "image_filter_buffer size;",
          "default": "image_filter_buffer 1M;",
          "context": "http, server, location",
          "description": "\nSets the maximum size of the buffer used for reading images.\nWhen the size is exceeded the server returns error\n415 (Unsupported Media Type).\n"
        },
        {
          "name": "image_filter_interlace",
          "syntax": "image_filter_interlace on | off;",
          "default": "image_filter_interlace off;",
          "context": "http, server, location",
          "description": "\nIf enabled, final images will be interlaced.\nFor JPEG, final images will be in “progressive JPEG” format.\n"
        },
        {
          "name": "image_filter_jpeg_quality",
          "syntax": "image_filter_jpeg_quality quality;",
          "default": "image_filter_jpeg_quality 75;",
          "context": "http, server, location",
          "description": "\nSets the desired quality of the transformed JPEG images.\nAcceptable values are in the range from 1 to 100.\nLesser values usually imply both lower image quality and less data to transfer.\nThe maximum recommended value is 95.\nParameter value can contain variables.\n"
        },
        {
          "name": "image_filter_sharpen",
          "syntax": "image_filter_sharpen percent;",
          "default": "image_filter_sharpen 0;",
          "context": "http, server, location",
          "description": "\nIncreases sharpness of the final image.\nThe sharpness percentage can exceed 100.\nThe zero value disables sharpening.\nParameter value can contain variables.\n"
        },
        {
          "name": "image_filter_transparency",
          "syntax": "image_filter_transparency on|off;",
          "default": "image_filter_transparency on;",
          "context": "http, server, location",
          "description": "\nDefines whether transparency should be preserved when transforming\nGIF images or PNG images with colors specified by a palette.\nThe loss of transparency results in images of a better quality.\nThe alpha channel transparency in PNG is always preserved.\n"
        },
        {
          "name": "image_filter_webp_quality",
          "syntax": "image_filter_webp_quality quality;",
          "default": "image_filter_webp_quality 80;",
          "context": "http, server, location",
          "description": "\nSets the desired quality of the transformed WebP images.\nAcceptable values are in the range from 1 to 100.\nLesser values usually imply both lower image quality and less data to transfer.\nParameter value can contain variables.\n"
        }
      ]
    },
    {
      "name": "ngx_http_index_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_index_module.html",
      "directives": [
        {
          "name": "index",
          "syntax": "index file ...;",
          "default": "index index.html;",
          "context": "http, server, location",
          "description": "\nDefines files that will be used as an index.\nThe file name can contain variables.\nFiles are checked in the specified order.\nThe last element of the list can be a file with an absolute path.\nExample:\n\nindex index.$geo.html index.0.html /index.html;\n\n \n\n\nIt should be noted that using an index file causes an internal redirect,\nand the request can be processed in a different location.\nFor example, with the following configuration:\n\nlocation = / {\n    index index.html;\n}\n\nlocation / {\n    ...\n}\n\n \na “/” request will actually be processed in the\nsecond location as “/index.html”.\n"
        }
      ]
    },
    {
      "name": "ngx_http_limit_conn_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_limit_conn_module.html",
      "directives": [
        {
          "name": "limit_conn",
          "syntax": "limit_conn zone number;",
          "context": "http, server, location",
          "description": "\nSets the shared memory zone\nand the maximum allowed number of connections for a given key value.\nWhen this limit is exceeded, the server will return the\nerror\nin reply to a request.\nFor example, the directives\n\nlimit_conn_zone $binary_remote_addr zone=addr:10m;\n\nserver {\n    location /download/ {\n        limit_conn addr 1;\n    }\n\n \nallow only one connection per an IP address at a time.\n\n\nIn HTTP/2 and SPDY, each concurrent request is considered a separate connection.\n\n \n\n\nThere could be several limit_conn directives.\nFor example, the following configuration will limit the number\nof connections to the server per a client IP and, at the same time,\nthe total number of connections to the virtual server:\n\nlimit_conn_zone $binary_remote_addr zone=perip:10m;\nlimit_conn_zone $server_name zone=perserver:10m;\n\nserver {\n    ...\n    limit_conn perip 10;\n    limit_conn perserver 100;\n}\n\n \n\n\n\nThese directives are inherited from the previous level if and\nonly if there are no\nlimit_conn\ndirectives on the current level.\n"
        },
        {
          "name": "limit_conn_log_level",
          "syntax": "limit_conn_log_level info | notice | warn | error;",
          "default": "limit_conn_log_level error;",
          "context": "http, server, location",
          "description": "\nSets the desired logging level for cases when the server\nlimits the number of connections.\n"
        },
        {
          "name": "limit_conn_status",
          "syntax": "limit_conn_status code;",
          "default": "limit_conn_status 503;",
          "context": "http, server, location",
          "description": "\nSets the status code to return in response to rejected requests.\n"
        },
        {
          "name": "limit_conn_zone",
          "syntax": "limit_conn_zone key zone=name:size;",
          "context": "http",
          "description": "\nSets parameters for a shared memory zone\nthat will keep states for various keys.\nIn particular, the state includes the current number of connections.\nThe key can contain text, variables, and their combination.\nRequests with an empty key value are not accounted.\n\n\nPrior to version 1.7.6, a key could contain exactly one variable.\n\n \nUsage example:\n\nlimit_conn_zone $binary_remote_addr zone=addr:10m;\n\n \nHere, a client IP address serves as a key.\nNote that instead of $remote_addr, the\n$binary_remote_addr variable is used here.\nThe $remote_addr variable’s size can\nvary from 7 to 15 bytes.\nThe stored state occupies either\n32 or 64 bytes of memory on 32-bit platforms and always 64\nbytes on 64-bit platforms.\nThe $binary_remote_addr variable’s size\nis always 4 bytes for IPv4 addresses or 16 bytes for IPv6 addresses.\nThe stored state always occupies 32 or 64 bytes\non 32-bit platforms and 64 bytes on 64-bit platforms.\nOne megabyte zone can keep about 32 thousand 32-byte states\nor about 16 thousand 64-byte states.\nIf the zone storage is exhausted, the server will return the\nerror\nto all further requests.\n"
        },
        {
          "name": "limit_zone",
          "syntax": "limit_zone name $variable size;",
          "context": "http",
          "description": "\nThis directive was made obsolete in version 1.1.8\nand was removed in version 1.7.6.\nAn equivalent limit_conn_zone directive\nwith a changed syntax should be used instead:\n\n\nlimit_conn_zone\n$variable\nzone=name:size;\n\n \n"
        }
      ]
    },
    {
      "name": "ngx_http_limit_req_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_limit_req_module.html",
      "directives": [
        {
          "name": "limit_req",
          "syntax": "limit_req zone=name [burst=number] [nodelay | delay=number];",
          "context": "http, server, location",
          "description": "\nSets the shared memory zone\nand the maximum burst size of requests.\nIf the requests rate exceeds the rate configured for a zone,\ntheir processing is delayed such that requests are processed\nat a defined rate.\nExcessive requests are delayed until their number exceeds the\nmaximum burst size\nin which case the request is terminated with an\nerror.\nBy default, the maximum burst size is equal to zero.\nFor example, the directives\n\nlimit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;\n\nserver {\n    location /search/ {\n        limit_req zone=one burst=5;\n    }\n\n \nallow not more than 1 request per second at an average,\nwith bursts not exceeding 5 requests.\n\n\nIf delaying of excessive requests while requests are being limited is not\ndesired, the parameter nodelay should be used:\n\nlimit_req zone=one burst=5 nodelay;\n\n \n"
        },
        {
          "name": "limit_req_dry_run",
          "syntax": "limit_req_dry_run on | off;",
          "default": "limit_req_dry_run on;",
          "context": "http, server, location",
          "description": "\nEnables the dry run mode.\nIn this mode, requests processing rate is not limited, however,\nin the shared memory zone, the number of excessive requests is accounted\nas usual.\n"
        },
        {
          "name": "limit_req_log_level",
          "syntax": "limit_req_log_level info | notice | warn | error;",
          "default": "limit_req_log_level error;",
          "context": "http, server, location",
          "description": "\nSets the desired logging level\nfor cases when the server refuses to process requests\ndue to rate exceeding,\nor delays request processing.\nLogging level for delays is one point less than for refusals; for example,\nif “limit_req_log_level notice” is specified,\ndelays are logged with the info level.\n"
        },
        {
          "name": "limit_req_status",
          "syntax": "limit_req_status code;",
          "default": "limit_req_status 503;",
          "context": "http, server, location",
          "description": "\nSets the status code to return in response to rejected requests.\n"
        },
        {
          "name": "limit_req_zone",
          "syntax": "limit_req_zone key zone=name:size rate=rate [sync];",
          "context": "http",
          "description": "\nSets parameters for a shared memory zone\nthat will keep states for various keys.\nIn particular, the state stores the current number of excessive requests.\nThe key can contain text, variables, and their combination.\nRequests with an empty key value are not accounted.\n\n\nPrior to version 1.7.6, a key could contain exactly one variable.\n\n \nUsage example:\n\nlimit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;\n\n \n\n\nHere, the states are kept in a 10 megabyte zone “one”, and an\naverage request processing rate for this zone cannot exceed\n1 request per second.\n\n\nA client IP address serves as a key.\nNote that instead of $remote_addr, the\n$binary_remote_addr variable is used here.\nThe $binary_remote_addr variable’s size\nis always 4 bytes for IPv4 addresses or 16 bytes for IPv6 addresses.\nThe stored state always occupies\n64 bytes on 32-bit platforms and 128 bytes on 64-bit platforms.\nOne megabyte zone can keep about 16 thousand 64-byte states\nor about 8 thousand 128-byte states.\n\n\nIf the zone storage is exhausted, the least recently used state is removed.\nEven if after that a new state cannot be created, the request is terminated with\nan error.\n\n\nThe rate is specified in requests per second (r/s).\nIf a rate of less than one request per second is desired,\nit is specified in request per minute (r/m).\nFor example, half-request per second is 30r/m.\n"
        }
      ]
    },
    {
      "name": "ngx_http_log_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_log_module.html",
      "directives": [
        {
          "name": "access_log",
          "syntax": "access_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]];access_log off;",
          "default": "access_log logs/access.log combined;",
          "context": "http, server, location, if in location, limit_except",
          "description": "\nSets the path, format, and configuration for a buffered log write.\nSeveral logs can be specified on the same level.\nLogging to syslog\ncan be configured by specifying\nthe “syslog:” prefix in the first parameter.\nThe special value off cancels all\naccess_log directives on the current level.\nIf the format is not specified then the predefined\n“combined” format is used.\n\n\nIf either the buffer or gzip\n(1.3.10, 1.2.7)\nparameter is used, writes to log will be buffered.\n\n\nThe buffer size must not exceed the size of an atomic write to a disk file.\nFor FreeBSD this size is unlimited.\n\n \n\n\nWhen buffering is enabled, the data will be written to the file:\n\n\n\n\nif the next log line does not fit into the buffer;\n\n\n\nif the buffered data is older than specified by the flush\nparameter (1.3.10, 1.2.7);\n\n\n\nwhen a worker process is re-opening log\nfiles or is shutting down.\n\n\n\n \n\n\nIf the gzip parameter is used, then the buffered data will\nbe compressed before writing to the file.\nThe compression level can be set between 1 (fastest, less compression)\nand 9 (slowest, best compression).\nBy default, the buffer size is equal to 64K bytes, and the compression level\nis set to 1.\nSince the data is compressed in atomic blocks, the log file can be decompressed\nor read by “zcat” at any time.\n\n\nExample:\n\naccess_log /path/to/log.gz combined gzip flush=5m;\n\n \n\n\n\n\nFor gzip compression to work, nginx must be built with the zlib library.\n\n \n\n\nThe file path can contain variables (0.7.6+),\nbut such logs have some constraints:\n\n\n\n\nthe user\nwhose credentials are used by worker processes should\nhave permissions to create files in a directory with\nsuch logs;\n\n\n\nbuffered writes do not work;\n\n\n\nthe file is opened and closed for each log write.\nHowever, since the descriptors of frequently used files can be stored\nin a cache, writing to the old file\ncan continue during the time specified by the open_log_file_cache\ndirective’s valid parameter\n\n\n\nduring each log write the existence of the request’s\nroot directory\nis checked, and if it does not exist the log is not\ncreated.\nIt is thus a good idea to specify both\nroot\nand access_log on the same level:\nserver {\n    root       /spool/vhost/data/$host;\n    access_log /spool/vhost/logs/$host;\n    ...\n\n\n\n\n \n\n\nThe if parameter (1.7.0) enables conditional logging.\nA request will not be logged if the condition evaluates to “0”\nor an empty string.\nIn the following example, the requests with response codes 2xx and 3xx\nwill not be logged:\n\nmap $status $loggable {\n    ~^[23]  0;\n    default 1;\n}\n\naccess_log /path/to/access.log combined if=$loggable;\n\n \n"
        },
        {
          "name": "log_format",
          "syntax": "log_format name [escape=default|json|none] string ...;",
          "default": "log_format combined \"...\";",
          "context": "http",
          "description": "\nSpecifies log format.\n"
        },
        {
          "name": "open_log_file_cache",
          "syntax": "open_log_file_cache max=N [inactive=time] [min_uses=N] [valid=time];open_log_file_cache off;",
          "default": "open_log_file_cache off;",
          "context": "http, server, location",
          "description": "\nDefines a cache that stores the file descriptors of frequently used logs\nwhose names contain variables.\nThe directive has the following parameters:\n\n\n\nmax\n\nsets the maximum number of descriptors in a cache;\nif the cache becomes full the least recently used (LRU)\ndescriptors are closed\n\n\ninactive\n\nsets the time after which the cached descriptor is closed\nif there were no access during this time;\nby default, 10 seconds\n\n\nmin_uses\n\nsets the minimum number of file uses during the time\ndefined by the inactive parameter\nto let the descriptor stay open in a cache;\nby default, 1\n\n\nvalid\n\nsets the time after which it should be checked that the file\nstill exists with the same name; by default, 60 seconds\n\n\noff\n\ndisables caching\n\n\n\n \n\n\nUsage example:\n\nopen_log_file_cache max=1000 inactive=20s valid=1m min_uses=2;\n\n \n"
        }
      ]
    },
    {
      "name": "ngx_http_map_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_map_module.html",
      "directives": [
        {
          "name": "map",
          "syntax": "map string $variable { ... }",
          "context": "http",
          "description": "\nCreates a new variable whose value\ndepends on values of one or more of the source variables\nspecified in the first parameter.\n\n\nBefore version 0.9.0 only a single variable could be\nspecified in the first parameter.\n\n \n\n\n\n\nSince variables are evaluated only when they are used, the mere declaration\neven of a large number of “map” variables\ndoes not add any extra costs to request processing.\n\n \n\n\nParameters inside the map block specify a mapping\nbetween source and resulting values.\n\n\nSource values are specified as strings or regular expressions (0.9.6).\n\n\nStrings are matched ignoring the case.\n\n\nA regular expression should either start from the “~”\nsymbol for a case-sensitive matching, or from the “~*”\nsymbols (1.0.4) for case-insensitive matching.\nA regular expression can contain named and positional captures\nthat can later be used in other directives along with the\nresulting variable.\n\n\nIf a source value matches one of the names of special parameters\ndescribed below, it should be prefixed with the “\\” symbol.\n\n\nThe resulting value can contain text,\nvariable (0.9.0), and their combination (1.11.0).\n\n\nThe following special parameters are also supported:\n\n\ndefault value\n\nsets the resulting value if the source value matches none\nof the specified variants.\nWhen default is not specified, the default\nresulting value will be an empty string.\n\n\nhostnames\n\nindicates that source values can be hostnames with a prefix or suffix mask:\n*.example.com 1;\nexample.*     1;\n\nThe following two records\nexample.com   1;\n*.example.com 1;\n\ncan be combined:\n.example.com  1;\n\nThis parameter should be specified before the list of values.\n\n\ninclude file\n\nincludes a file with values.\nThere can be several inclusions.\n\n\nvolatile\n\nindicates that the variable is not cacheable (1.11.7).\n\n\n\n \n\n\nIf the source value matches more than one of the specified variants,\ne.g. both a mask and a regular expression match, the first matching\nvariant will be chosen, in the following order of priority:\n\n\n\n\nstring value without a mask\n\n\n\nlongest string value with a prefix mask,\ne.g. “*.example.com”\n\n\n\nlongest string value with a suffix mask,\ne.g. “mail.*”\n\n\n\nfirst matching regular expression\n(in order of appearance in a configuration file)\n\n\n\ndefault value\n\n\n\n \n"
        },
        {
          "name": "map_hash_bucket_size",
          "syntax": "map_hash_bucket_size size;",
          "default": "map_hash_bucket_size 32|64|128;",
          "context": "http",
          "description": "\nSets the bucket size for the map variables hash tables.\nDefault value depends on the processor’s cache line size.\nThe details of setting up hash tables are provided in a separate\ndocument.\n"
        },
        {
          "name": "map_hash_max_size",
          "syntax": "map_hash_max_size size;",
          "default": "map_hash_max_size 2048;",
          "context": "http",
          "description": "\nSets the maximum size of the map variables\nhash tables.\nThe details of setting up hash tables are provided in a separate\ndocument.\n"
        }
      ]
    },
    {
      "name": "ngx_http_mirror_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_mirror_module.html",
      "directives": [
        {
          "name": "mirror",
          "syntax": "mirror uri | off;",
          "default": "mirror off;",
          "context": "http, server, location",
          "description": "\nSets the URI to which an original request will be mirrored.\nSeveral mirrors can be specified on the same level.\n"
        },
        {
          "name": "mirror_request_body",
          "syntax": "mirror_request_body on | off;",
          "default": "mirror_request_body on;",
          "context": "http, server, location",
          "description": "\nIndicates whether the client request body is mirrored.\nWhen enabled, the client request body will be read\nprior to creating mirror subrequests.\nIn this case, unbuffered client request body proxying\nset by the\nproxy_request_buffering,\nfastcgi_request_buffering,\nscgi_request_buffering,\nand\nuwsgi_request_buffering\ndirectives will be disabled.\n\nlocation / {\n    mirror /mirror;\n    mirror_request_body off;\n    proxy_pass http://backend;\n}\n\nlocation = /mirror {\n    internal;\n    proxy_pass http://log_backend;\n    proxy_pass_request_body off;\n    proxy_set_header Content-Length \"\";\n    proxy_set_header X-Original-URI $request_uri;\n}\n\n \n"
        }
      ]
    },
    {
      "name": "ngx_http_proxy_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_proxy_module.html",
      "directives": [
        {
          "name": "proxy_bind",
          "syntax": "proxy_bind address [transparent] | off;",
          "context": "http, server, location",
          "description": "\nMakes outgoing connections to a proxied server originate\nfrom the specified local IP address with an optional port (1.11.2).\nParameter value can contain variables (1.3.12).\nThe special value off (1.3.12) cancels the effect\nof the proxy_bind directive\ninherited from the previous configuration level, which allows the\nsystem to auto-assign the local IP address and port.\n"
        },
        {
          "name": "proxy_buffer_size",
          "syntax": "proxy_buffer_size size;",
          "default": "proxy_buffer_size 4k|8k;",
          "context": "http, server, location",
          "description": "\nSets the size of the buffer used for reading the first part\nof the response received from the proxied server.\nThis part usually contains a small response header.\nBy default, the buffer size is equal to one memory page.\nThis is either 4K or 8K, depending on a platform.\nIt can be made smaller, however.\n"
        },
        {
          "name": "proxy_buffering",
          "syntax": "proxy_buffering on | off;",
          "default": "proxy_buffering on;",
          "context": "http, server, location",
          "description": "\nEnables or disables buffering of responses from the proxied server.\n\n\nWhen buffering is enabled, nginx receives a response from the proxied server\nas soon as possible, saving it into the buffers set by the\nproxy_buffer_size and proxy_buffers directives.\nIf the whole response does not fit into memory, a part of it can be saved\nto a temporary file on the disk.\nWriting to temporary files is controlled by the\nproxy_max_temp_file_size and\nproxy_temp_file_write_size directives.\n\n\nWhen buffering is disabled, the response is passed to a client synchronously,\nimmediately as it is received.\nnginx will not try to read the whole response from the proxied server.\nThe maximum size of the data that nginx can receive from the server\nat a time is set by the proxy_buffer_size directive.\n\n\nBuffering can also be enabled or disabled by passing\n“yes” or “no” in the\n“X-Accel-Buffering” response header field.\nThis capability can be disabled using the\nproxy_ignore_headers directive.\n"
        },
        {
          "name": "proxy_buffers",
          "syntax": "proxy_buffers number size;",
          "default": "proxy_buffers 8 4k|8k;",
          "context": "http, server, location",
          "description": "\nSets the number and size of the\nbuffers used for reading a response from the proxied server,\nfor a single connection.\nBy default, the buffer size is equal to one memory page.\nThis is either 4K or 8K, depending on a platform.\n"
        },
        {
          "name": "proxy_busy_buffers_size",
          "syntax": "proxy_busy_buffers_size size;",
          "default": "proxy_busy_buffers_size 8k|16k;",
          "context": "http, server, location",
          "description": "\nWhen buffering of responses from the proxied\nserver is enabled, limits the total size of buffers that\ncan be busy sending a response to the client while the response is not\nyet fully read.\nIn the meantime, the rest of the buffers can be used for reading the response\nand, if needed, buffering part of the response to a temporary file.\nBy default, size is limited by the size of two buffers set by the\nproxy_buffer_size and proxy_buffers directives.\n"
        },
        {
          "name": "proxy_cache",
          "syntax": "proxy_cache zone | off;",
          "default": "proxy_cache off;",
          "context": "http, server, location",
          "description": "\nDefines a shared memory zone used for caching.\nThe same zone can be used in several places.\nParameter value can contain variables (1.7.9).\nThe off parameter disables caching inherited\nfrom the previous configuration level.\n"
        },
        {
          "name": "proxy_cache_background_update",
          "syntax": "proxy_cache_background_update on | off;",
          "default": "proxy_cache_background_update off;",
          "context": "http, server, location",
          "description": "\nAllows starting a background subrequest\nto update an expired cache item,\nwhile a stale cached response is returned to the client.\nNote that it is necessary to\nallow\nthe usage of a stale cached response when it is being updated.\n"
        },
        {
          "name": "proxy_cache_bypass",
          "syntax": "proxy_cache_bypass string ...;",
          "context": "http, server, location",
          "description": "\nDefines conditions under which the response will not be taken from a cache.\nIf at least one value of the string parameters is not empty and is not\nequal to “0” then the response will not be taken from the cache:\n\nproxy_cache_bypass $cookie_nocache $arg_nocache$arg_comment;\nproxy_cache_bypass $http_pragma    $http_authorization;\n\n \nCan be used along with the proxy_no_cache directive.\n"
        },
        {
          "name": "proxy_cache_convert_head",
          "syntax": "proxy_cache_convert_head on | off;",
          "default": "proxy_cache_convert_head on;",
          "context": "http, server, location",
          "description": "\nEnables or disables the conversion of the “HEAD” method\nto “GET” for caching.\nWhen the conversion is disabled, the\ncache key should be configured\nto include the $request_method.\n"
        },
        {
          "name": "proxy_cache_key",
          "syntax": "proxy_cache_key string;",
          "default": "proxy_cache_key $scheme$proxy_host$request_uri;",
          "context": "http, server, location",
          "description": "\nDefines a key for caching, for example\n\nproxy_cache_key \"$host$request_uri $cookie_user\";\n\n \nBy default, the directive’s value is close to the string\n\nproxy_cache_key $scheme$proxy_host$uri$is_args$args;\n\n \n"
        },
        {
          "name": "proxy_cache_lock",
          "syntax": "proxy_cache_lock on | off;",
          "default": "proxy_cache_lock off;",
          "context": "http, server, location",
          "description": "\nWhen enabled, only one request at a time will be allowed to populate\na new cache element identified according to the proxy_cache_key\ndirective by passing a request to a proxied server.\nOther requests of the same cache element will either wait\nfor a response to appear in the cache or the cache lock for\nthis element to be released, up to the time set by the\nproxy_cache_lock_timeout directive.\n"
        },
        {
          "name": "proxy_cache_lock_age",
          "syntax": "proxy_cache_lock_age time;",
          "default": "proxy_cache_lock_age 5s;",
          "context": "http, server, location",
          "description": "\nIf the last request passed to the proxied server\nfor populating a new cache element\nhas not completed for the specified time,\none more request may be passed to the proxied server.\n"
        },
        {
          "name": "proxy_cache_lock_timeout",
          "syntax": "proxy_cache_lock_timeout time;",
          "default": "proxy_cache_lock_timeout 5s;",
          "context": "http, server, location",
          "description": "\nSets a timeout for proxy_cache_lock.\nWhen the time expires,\nthe request will be passed to the proxied server,\nhowever, the response will not be cached.\n\n\nBefore 1.7.8, the response could be cached.\n\n \n"
        },
        {
          "name": "proxy_cache_max_range_offset",
          "syntax": "proxy_cache_max_range_offset number;",
          "context": "http, server, location",
          "description": "\nSets an offset in bytes for byte-range requests.\nIf the range is beyond the offset,\nthe range request will be passed to the proxied server\nand the response will not be cached.\n"
        },
        {
          "name": "proxy_cache_methods",
          "syntax": "proxy_cache_methods GET | HEAD | POST ...;",
          "default": "proxy_cache_methods GET HEAD;",
          "context": "http, server, location",
          "description": "\nIf the client request method is listed in this directive then\nthe response will be cached.\n“GET” and “HEAD” methods are always\nadded to the list, though it is recommended to specify them explicitly.\nSee also the proxy_no_cache directive.\n"
        },
        {
          "name": "proxy_cache_min_uses",
          "syntax": "proxy_cache_min_uses number;",
          "default": "proxy_cache_min_uses 1;",
          "context": "http, server, location",
          "description": "\nSets the number of requests after which the response\nwill be cached.\n"
        },
        {
          "name": "proxy_cache_revalidate",
          "syntax": "proxy_cache_revalidate on | off;",
          "default": "proxy_cache_revalidate off;",
          "context": "http, server, location",
          "description": "\nEnables revalidation of expired cache items using conditional requests with\nthe “If-Modified-Since” and “If-None-Match”\nheader fields.\n"
        },
        {
          "name": "proxy_cache_use_stale",
          "syntax": "proxy_cache_use_stale error | timeout | invalid_header | updating | http_500 | http_502 | http_503 | http_504 | http_403 | http_404 | http_429 | off ...;",
          "default": "proxy_cache_use_stale off;",
          "context": "http, server, location",
          "description": "\nDetermines in which cases a stale cached response can be used\nduring communication with the proxied server.\nThe directive’s parameters match the parameters of the\nproxy_next_upstream directive.\n\n\nThe error parameter also permits\nusing a stale cached response if a proxied server to process a request\ncannot be selected.\n"
        },
        {
          "name": "proxy_cache_valid",
          "syntax": "proxy_cache_valid [code ...] time;",
          "context": "http, server, location",
          "description": "\nSets caching time for different response codes.\nFor example, the following directives\n\nproxy_cache_valid 200 302 10m;\nproxy_cache_valid 404      1m;\n\n \nset 10 minutes of caching for responses with codes 200 and 302\nand 1 minute for responses with code 404.\n\n\nIf only caching time is specified\n\nproxy_cache_valid 5m;\n\n \nthen only 200, 301, and 302 responses are cached.\n\n\nIn addition, the any parameter can be specified\nto cache any responses:\n\nproxy_cache_valid 200 302 10m;\nproxy_cache_valid 301      1h;\nproxy_cache_valid any      1m;\n\n \n\n\nParameters of caching can also be set directly\nin the response header.\nThis has higher priority than setting of caching time using the directive.\n\n\n\n\nThe “X-Accel-Expires” header field sets caching time of a\nresponse in seconds.\nThe zero value disables caching for a response.\nIf the value starts with the @ prefix, it sets an absolute\ntime in seconds since Epoch, up to which the response may be cached.\n\n\n\nIf the header does not include the “X-Accel-Expires” field,\nparameters of caching may be set in the header fields\n“Expires” or “Cache-Control”.\n\n\n\nIf the header includes the “Set-Cookie” field, such a\nresponse will not be cached.\n\n\n\nIf the header includes the “Vary” field\nwith the special value “*”, such a\nresponse will not be cached (1.7.7).\nIf the header includes the “Vary” field\nwith another value, such a response will be cached\ntaking into account the corresponding request header fields (1.7.7).\n\n\n\n \nProcessing of one or more of these response header fields can be disabled\nusing the proxy_ignore_headers directive.\n"
        },
        {
          "name": "proxy_connect_timeout",
          "syntax": "proxy_connect_timeout time;",
          "default": "proxy_connect_timeout 60s;",
          "context": "http, server, location",
          "description": "\nDefines a timeout for establishing a connection with a proxied server.\nIt should be noted that this timeout cannot usually exceed 75 seconds.\n"
        },
        {
          "name": "proxy_cookie_domain",
          "syntax": "proxy_cookie_domain off;proxy_cookie_domain domain replacement;",
          "default": "proxy_cookie_domain off;",
          "context": "http, server, location",
          "description": "\nSets a text that should be changed in the domain\nattribute of the “Set-Cookie” header fields of a\nproxied server response.\nSuppose a proxied server returned the “Set-Cookie”\nheader field with the attribute\n“domain=localhost”.\nThe directive\n\nproxy_cookie_domain localhost example.org;\n\n \nwill rewrite this attribute to\n“domain=example.org”.\n\n\nA dot at the beginning of the domain and\nreplacement strings and the domain\nattribute is ignored.\nMatching is case-insensitive.\n\n\nThe domain and replacement strings\ncan contain variables:\n\nproxy_cookie_domain www.$host $host;\n\n \n\n\nThe directive can also be specified using regular expressions.\nIn this case, domain should start from\nthe “~” symbol.\nA regular expression can contain named and positional captures,\nand replacement can reference them:\n\nproxy_cookie_domain ~\\.(?P<sl_domain>[-0-9a-z]+\\.[a-z]+)$ $sl_domain;\n\n \n\n\nThere could be several proxy_cookie_domain directives:\n\nproxy_cookie_domain localhost example.org;\nproxy_cookie_domain ~\\.([a-z]+\\.[a-z]+)$ $1;\n\n \n\n\nThe off parameter cancels the effect of all\nproxy_cookie_domain directives on the current level:\n\nproxy_cookie_domain off;\nproxy_cookie_domain localhost example.org;\nproxy_cookie_domain www.example.org example.org;\n\n \n"
        },
        {
          "name": "proxy_cookie_path",
          "syntax": "proxy_cookie_path off;proxy_cookie_path path replacement;",
          "default": "proxy_cookie_path off;",
          "context": "http, server, location",
          "description": "\nSets a text that should be changed in the path\nattribute of the “Set-Cookie” header fields of a\nproxied server response.\nSuppose a proxied server returned the “Set-Cookie”\nheader field with the attribute\n“path=/two/some/uri/”.\nThe directive\n\nproxy_cookie_path /two/ /;\n\n \nwill rewrite this attribute to\n“path=/some/uri/”.\n\n\nThe path and replacement strings\ncan contain variables:\n\nproxy_cookie_path $uri /some$uri;\n\n \n\n\nThe directive can also be specified using regular expressions.\nIn this case, path should either start from\nthe “~” symbol for a case-sensitive matching,\nor from the “~*” symbols for case-insensitive\nmatching.\nThe regular expression can contain named and positional captures,\nand replacement can reference them:\n\nproxy_cookie_path ~*^/user/([^/]+) /u/$1;\n\n \n\n\nThere could be several proxy_cookie_path directives:\n\nproxy_cookie_path /one/ /;\nproxy_cookie_path / /two/;\n\n \n\n\nThe off parameter cancels the effect of all\nproxy_cookie_path directives on the current level:\n\nproxy_cookie_path off;\nproxy_cookie_path /two/ /;\nproxy_cookie_path ~*^/user/([^/]+) /u/$1;\n\n \n"
        },
        {
          "name": "proxy_force_ranges",
          "syntax": "proxy_force_ranges on | off;",
          "default": "proxy_force_ranges off;",
          "context": "http, server, location",
          "description": "\nEnables byte-range support\nfor both cached and uncached responses from the proxied server\nregardless of the “Accept-Ranges” field in these responses.\n"
        },
        {
          "name": "proxy_headers_hash_bucket_size",
          "syntax": "proxy_headers_hash_bucket_size size;",
          "default": "proxy_headers_hash_bucket_size 64;",
          "context": "http, server, location",
          "description": "\nSets the bucket size for hash tables\nused by the proxy_hide_header and proxy_set_header\ndirectives.\nThe details of setting up hash tables are provided in a separate\ndocument.\n"
        },
        {
          "name": "proxy_headers_hash_max_size",
          "syntax": "proxy_headers_hash_max_size size;",
          "default": "proxy_headers_hash_max_size 512;",
          "context": "http, server, location",
          "description": "\nSets the maximum size of hash tables\nused by the proxy_hide_header and proxy_set_header\ndirectives.\nThe details of setting up hash tables are provided in a separate\ndocument.\n"
        },
        {
          "name": "proxy_hide_header",
          "syntax": "proxy_hide_header field;",
          "context": "http, server, location",
          "description": "\nBy default,\nnginx does not pass the header fields “Date”,\n“Server”, “X-Pad”, and\n“X-Accel-...” from the response of a proxied\nserver to a client.\nThe proxy_hide_header directive sets additional fields\nthat will not be passed.\nIf, on the contrary, the passing of fields needs to be permitted,\nthe proxy_pass_header directive can be used.\n"
        },
        {
          "name": "proxy_http_version",
          "syntax": "proxy_http_version 1.0 | 1.1;",
          "default": "proxy_http_version 1.0;",
          "context": "http, server, location",
          "description": "\nSets the HTTP protocol version for proxying.\nBy default, version 1.0 is used.\nVersion 1.1 is recommended for use with\nkeepalive\nconnections and\nNTLM authentication.\n"
        },
        {
          "name": "proxy_ignore_client_abort",
          "syntax": "proxy_ignore_client_abort on | off;",
          "default": "proxy_ignore_client_abort off;",
          "context": "http, server, location",
          "description": "\nDetermines whether the connection with a proxied server should be\nclosed when a client closes the connection without waiting\nfor a response.\n"
        },
        {
          "name": "proxy_ignore_headers",
          "syntax": "proxy_ignore_headers field ...;",
          "context": "http, server, location",
          "description": "\nDisables processing of certain response header fields from the proxied server.\nThe following fields can be ignored: “X-Accel-Redirect”,\n“X-Accel-Expires”, “X-Accel-Limit-Rate” (1.1.6),\n“X-Accel-Buffering” (1.1.6),\n“X-Accel-Charset” (1.1.6), “Expires”,\n“Cache-Control”, “Set-Cookie” (0.8.44),\nand “Vary” (1.7.7).\n\n\nIf not disabled, processing of these header fields has the following\neffect:\n\n\n\n\n“X-Accel-Expires”, “Expires”,\n“Cache-Control”, “Set-Cookie”,\nand “Vary”\nset the parameters of response caching;\n\n\n\n“X-Accel-Redirect” performs an\ninternal\nredirect to the specified URI;\n\n\n\n“X-Accel-Limit-Rate” sets the\nrate\nlimit for transmission of a response to a client;\n\n\n\n“X-Accel-Buffering” enables or disables\nbuffering of a response;\n\n\n\n“X-Accel-Charset” sets the desired\ncharset\nof a response.\n\n\n\n \n"
        },
        {
          "name": "proxy_intercept_errors",
          "syntax": "proxy_intercept_errors on | off;",
          "default": "proxy_intercept_errors off;",
          "context": "http, server, location",
          "description": "\nDetermines whether proxied responses with codes greater than or equal\nto 300 should be passed to a client\nor be intercepted and redirected to nginx for processing\nwith the error_page directive.\n"
        },
        {
          "name": "proxy_limit_rate",
          "syntax": "proxy_limit_rate rate;",
          "default": "proxy_limit_rate 0;",
          "context": "http, server, location",
          "description": "\nLimits the speed of reading the response from the proxied server.\nThe rate is specified in bytes per second.\nThe zero value disables rate limiting.\nThe limit is set per a request, and so if nginx simultaneously opens\ntwo connections to the proxied server,\nthe overall rate will be twice as much as the specified limit.\nThe limitation works only if\nbuffering of responses from the proxied\nserver is enabled.\n"
        },
        {
          "name": "proxy_max_temp_file_size",
          "syntax": "proxy_max_temp_file_size size;",
          "default": "proxy_max_temp_file_size 1024m;",
          "context": "http, server, location",
          "description": "\nWhen buffering of responses from the proxied\nserver is enabled, and the whole response does not fit into the buffers\nset by the proxy_buffer_size and proxy_buffers\ndirectives, a part of the response can be saved to a temporary file.\nThis directive sets the maximum size of the temporary file.\nThe size of data written to the temporary file at a time is set\nby the proxy_temp_file_write_size directive.\n\n\nThe zero value disables buffering of responses to temporary files.\n\n\n\n\nThis restriction does not apply to responses\nthat will be cached\nor stored on disk.\n\n \n"
        },
        {
          "name": "proxy_method",
          "syntax": "proxy_method method;",
          "context": "http, server, location",
          "description": "\nSpecifies the HTTP method to use in requests forwarded\nto the proxied server instead of the method from the client request.\nParameter value can contain variables (1.11.6).\n"
        },
        {
          "name": "proxy_next_upstream",
          "syntax": "proxy_next_upstream error | timeout | invalid_header | http_500 | http_502 | http_503 | http_504 | http_403 | http_404 | http_429 | non_idempotent | off ...;",
          "default": "proxy_next_upstream error timeout;",
          "context": "http, server, location",
          "description": "\nSpecifies in which cases a request should be passed to the next server:\n\n\n\nerror\nan error occurred while establishing a connection with the\nserver, passing a request to it, or reading the response header;\n\ntimeout\na timeout has occurred while establishing a connection with the\nserver, passing a request to it, or reading the response header;\n\ninvalid_header\na server returned an empty or invalid response;\n\nhttp_500\na server returned a response with the code 500;\n\nhttp_502\na server returned a response with the code 502;\n\nhttp_503\na server returned a response with the code 503;\n\nhttp_504\na server returned a response with the code 504;\n\nhttp_403\na server returned a response with the code 403;\n\nhttp_404\na server returned a response with the code 404;\n\nhttp_429\na server returned a response with the code 429 (1.11.13);\n\nnon_idempotent\nnormally, requests with a\nnon-idempotent\nmethod\n(POST, LOCK, PATCH)\nare not passed to the next server\nif a request has been sent to an upstream server (1.9.13);\nenabling this option explicitly allows retrying such requests;\n\n\noff\ndisables passing a request to the next server.\n\n\n \n\n\nOne should bear in mind that passing a request to the next server is\nonly possible if nothing has been sent to a client yet.\nThat is, if an error or timeout occurs in the middle of the\ntransferring of a response, fixing this is impossible.\n\n\nThe directive also defines what is considered an\nunsuccessful\nattempt of communication with a server.\nThe cases of error, timeout and\ninvalid_header are always considered unsuccessful attempts,\neven if they are not specified in the directive.\nThe cases of http_500, http_502,\nhttp_503, http_504,\nand http_429 are\nconsidered unsuccessful attempts only if they are specified in the directive.\nThe cases of http_403 and http_404\nare never considered unsuccessful attempts.\n\n\nPassing a request to the next server can be limited by\nthe number of tries\nand by time.\n"
        },
        {
          "name": "proxy_next_upstream_timeout",
          "syntax": "proxy_next_upstream_timeout time;",
          "default": "proxy_next_upstream_timeout 0;",
          "context": "http, server, location",
          "description": "\nLimits the time during which a request can be passed to the\nnext server.\nThe 0 value turns off this limitation.\n"
        },
        {
          "name": "proxy_next_upstream_tries",
          "syntax": "proxy_next_upstream_tries number;",
          "default": "proxy_next_upstream_tries 0;",
          "context": "http, server, location",
          "description": "\nLimits the number of possible tries for passing a request to the\nnext server.\nThe 0 value turns off this limitation.\n"
        },
        {
          "name": "proxy_no_cache",
          "syntax": "proxy_no_cache string ...;",
          "context": "http, server, location",
          "description": "\nDefines conditions under which the response will not be saved to a cache.\nIf at least one value of the string parameters is not empty and is not\nequal to “0” then the response will not be saved:\n\nproxy_no_cache $cookie_nocache $arg_nocache$arg_comment;\nproxy_no_cache $http_pragma    $http_authorization;\n\n \nCan be used along with the proxy_cache_bypass directive.\n"
        },
        {
          "name": "proxy_pass",
          "syntax": "proxy_pass URL;",
          "context": "location, if in location, limit_except",
          "description": "\nSets the protocol and address of a proxied server and an optional URI\nto which a location should be mapped.\nAs a protocol, “http” or “https”\ncan be specified.\nThe address can be specified as a domain name or IP address,\nand an optional port:\n\nproxy_pass http://localhost:8000/uri/;\n\n \nor as a UNIX-domain socket path specified after the word\n“unix” and enclosed in colons:\n\nproxy_pass http://unix:/tmp/backend.socket:/uri/;\n\n \n\n\nIf a domain name resolves to several addresses, all of them will be\nused in a round-robin fashion.\nIn addition, an address can be specified as a\nserver group.\n\n\nParameter value can contain variables.\nIn this case, if an address is specified as a domain name,\nthe name is searched among the described server groups,\nand, if not found, is determined using a\nresolver.\n\n\nA request URI is passed to the server as follows:\n\n\n\n\nIf the proxy_pass directive is specified with a URI,\nthen when a request is passed to the server, the part of a\nnormalized\nrequest URI matching the location is replaced by a URI\nspecified in the directive:\nlocation /name/ {\n    proxy_pass http://127.0.0.1/remote/;\n}\n\n\n\n\nIf proxy_pass is specified without a URI,\nthe request URI is passed to the server in the same form\nas sent by a client when the original request is processed,\nor the full normalized request URI is passed\nwhen processing the changed URI:\nlocation /some/path/ {\n    proxy_pass http://127.0.0.1;\n}\n\n\nBefore version 1.1.12,\nif proxy_pass is specified without a URI,\nthe original request URI might be passed\ninstead of the changed URI in some cases.\n\n\n\n \n\n\nIn some cases, the part of a request URI to be replaced cannot be determined:\n\n\n\n\nWhen location is specified using a regular expression,\nand also inside named locations.\n\nIn these cases,\nproxy_pass should be specified without a URI.\n\n\n\n\nWhen the URI is changed inside a proxied location using the\nrewrite directive,\nand this same configuration will be used to process a request\n(break):\nlocation /name/ {\n    rewrite    /name/([^/]+) /users?name=$1 break;\n    proxy_pass http://127.0.0.1;\n}\n\n\nIn this case, the URI specified in the directive is ignored and\nthe full changed request URI is passed to the server.\n\n\n\n\nWhen variables are used in proxy_pass:\nlocation /name/ {\n    proxy_pass http://127.0.0.1$request_uri;\n}\n\nIn this case, if URI is specified in the directive,\nit is passed to the server as is,\nreplacing the original request URI.\n\n\n \n\n\nWebSocket proxying requires special\nconfiguration and is supported since version 1.3.13.\n"
        },
        {
          "name": "proxy_pass_header",
          "syntax": "proxy_pass_header field;",
          "context": "http, server, location",
          "description": "\nPermits passing otherwise disabled header\nfields from a proxied server to a client.\n"
        },
        {
          "name": "proxy_pass_request_body",
          "syntax": "proxy_pass_request_body on | off;",
          "default": "proxy_pass_request_body on;",
          "context": "http, server, location",
          "description": "\nIndicates whether the original request body is passed\nto the proxied server.\n\nlocation /x-accel-redirect-here/ {\n    proxy_method GET;\n    proxy_pass_request_body off;\n    proxy_set_header Content-Length \"\";\n\n    proxy_pass ...\n}\n\n \nSee also the proxy_set_header and\nproxy_pass_request_headers directives.\n"
        },
        {
          "name": "proxy_pass_request_headers",
          "syntax": "proxy_pass_request_headers on | off;",
          "default": "proxy_pass_request_headers on;",
          "context": "http, server, location",
          "description": "\nIndicates whether the header fields of the original request are passed\nto the proxied server.\n\nlocation /x-accel-redirect-here/ {\n    proxy_method GET;\n    proxy_pass_request_headers off;\n    proxy_pass_request_body off;\n\n    proxy_pass ...\n}\n\n \nSee also the proxy_set_header and\nproxy_pass_request_body directives.\n"
        },
        {
          "name": "proxy_read_timeout",
          "syntax": "proxy_read_timeout time;",
          "default": "proxy_read_timeout 60s;",
          "context": "http, server, location",
          "description": "\nDefines a timeout for reading a response from the proxied server.\nThe timeout is set only between two successive read operations,\nnot for the transmission of the whole response.\nIf the proxied server does not transmit anything within this time,\nthe connection is closed.\n"
        },
        {
          "name": "proxy_redirect",
          "syntax": "proxy_redirect default;proxy_redirect off;proxy_redirect redirect replacement;",
          "default": "proxy_redirect default;",
          "context": "http, server, location",
          "description": "\nSets the text that should be changed in the “Location”\nand “Refresh” header fields of a proxied server response.\nSuppose a proxied server returned the header field\n“Location: http://localhost:8000/two/some/uri/”.\nThe directive\n\nproxy_redirect http://localhost:8000/two/ http://frontend/one/;\n\n \nwill rewrite this string to\n“Location: http://frontend/one/some/uri/”.\n\n\nA server name may be omitted in the replacement string:\n\nproxy_redirect http://localhost:8000/two/ /;\n\n \nthen the primary server’s name and port, if different from 80,\nwill be inserted.\n\n\nThe default replacement specified by the default parameter\nuses the parameters of the\nlocation and\nproxy_pass directives.\nHence, the two configurations below are equivalent:\n\nlocation /one/ {\n    proxy_pass     http://upstream:port/two/;\n    proxy_redirect default;\n\n \n\n\nlocation /one/ {\n    proxy_pass     http://upstream:port/two/;\n    proxy_redirect http://upstream:port/two/ /one/;\n\n \nThe default parameter is not permitted if\nproxy_pass is specified using variables.\n\n\nA replacement string can contain variables:\n\nproxy_redirect http://localhost:8000/ http://$host:$server_port/;\n\n \n\n\nA redirect can also contain (1.1.11) variables:\n\nproxy_redirect http://$proxy_host:8000/ /;\n\n \n\n\nThe directive can be specified (1.1.11) using regular expressions.\nIn this case, redirect should either start with\nthe “~” symbol for a case-sensitive matching,\nor with the “~*” symbols for case-insensitive\nmatching.\nThe regular expression can contain named and positional captures,\nand replacement can reference them:\n\nproxy_redirect ~^(http://[^:]+):\\d+(/.+)$ $1$2;\nproxy_redirect ~*/user/([^/]+)/(.+)$      http://$1.example.com/$2;\n\n \n\n\nThere could be several proxy_redirect directives:\n\nproxy_redirect default;\nproxy_redirect http://localhost:8000/  /;\nproxy_redirect http://www.example.com/ /;\n\n \n\n\nThe off parameter cancels the effect of all\nproxy_redirect directives on the current level:\n\nproxy_redirect off;\nproxy_redirect default;\nproxy_redirect http://localhost:8000/  /;\nproxy_redirect http://www.example.com/ /;\n\n \n\n\nUsing this directive, it is also possible to add host names to relative\nredirects issued by a proxied server:\n\nproxy_redirect / /;\n\n \n"
        },
        {
          "name": "proxy_request_buffering",
          "syntax": "proxy_request_buffering on | off;",
          "default": "proxy_request_buffering on;",
          "context": "http, server, location",
          "description": "\nEnables or disables buffering of a client request body.\n\n\nWhen buffering is enabled, the entire request body is\nread\nfrom the client before sending the request to a proxied server.\n\n\nWhen buffering is disabled, the request body is sent to the proxied server\nimmediately as it is received.\nIn this case, the request cannot be passed to the\nnext server\nif nginx already started sending the request body.\n\n\nWhen HTTP/1.1 chunked transfer encoding is used\nto send the original request body,\nthe request body will be buffered regardless of the directive value unless\nHTTP/1.1 is enabled for proxying.\n"
        },
        {
          "name": "proxy_send_lowat",
          "syntax": "proxy_send_lowat size;",
          "default": "proxy_send_lowat 0;",
          "context": "http, server, location",
          "description": "\nIf the directive is set to a non-zero value, nginx will try to\nminimize the number\nof send operations on outgoing connections to a proxied server by using either\nNOTE_LOWAT flag of the\nkqueue method,\nor the SO_SNDLOWAT socket option,\nwith the specified size.\n\n\nThis directive is ignored on Linux, Solaris, and Windows.\n"
        },
        {
          "name": "proxy_send_timeout",
          "syntax": "proxy_send_timeout time;",
          "default": "proxy_send_timeout 60s;",
          "context": "http, server, location",
          "description": "\nSets a timeout for transmitting a request to the proxied server.\nThe timeout is set only between two successive write operations,\nnot for the transmission of the whole request.\nIf the proxied server does not receive anything within this time,\nthe connection is closed.\n"
        },
        {
          "name": "proxy_set_body",
          "syntax": "proxy_set_body value;",
          "context": "http, server, location",
          "description": "\nAllows redefining the request body passed to the proxied server.\nThe value can contain text, variables, and their combination.\n"
        },
        {
          "name": "proxy_set_header",
          "syntax": "proxy_set_header field value;",
          "default": "proxy_set_header Host $proxy_host;proxy_set_header Connection close;",
          "context": "http, server, location",
          "description": "\nAllows redefining or appending fields to the request header\npassed to the proxied server.\nThe value can contain text, variables, and their combinations.\nThese directives are inherited from the previous level if and\nonly if there are no\nproxy_set_header\ndirectives defined on the current level.\nBy default, only two fields are redefined:\n\nproxy_set_header Host       $proxy_host;\nproxy_set_header Connection close;\n\n \nIf caching is enabled, the header fields\n“If-Modified-Since”,\n“If-Unmodified-Since”,\n“If-None-Match”,\n“If-Match”,\n“Range”,\nand\n“If-Range”\nfrom the original request are not passed to the proxied server.\n\n\nAn unchanged “Host” request header field can be passed like this:\n\nproxy_set_header Host       $http_host;\n\n \n\n\nHowever, if this field is not present in a client request header then\nnothing will be passed.\nIn such a case it is better to use the $host variable - its\nvalue equals the server name in the “Host” request header\nfield or the primary server name if this field is not present:\n\nproxy_set_header Host       $host;\n\n \n\n\nIn addition, the server name can be passed together with the port of the\nproxied server:\n\nproxy_set_header Host       $host:$proxy_port;\n\n \n\n\nIf the value of a header field is an empty string then this\nfield will not be passed to a proxied server:\n\nproxy_set_header Accept-Encoding \"\";\n\n \n"
        },
        {
          "name": "proxy_socket_keepalive",
          "syntax": "proxy_socket_keepalive on | off;",
          "default": "proxy_socket_keepalive off;",
          "context": "http, server, location",
          "description": "\nConfigures the “TCP keepalive” behavior\nfor outgoing connections to a proxied server.\nBy default, the operating system’s settings are in effect for the socket.\nIf the directive is set to the value “on”, the\nSO_KEEPALIVE socket option is turned on for the socket.\n"
        },
        {
          "name": "proxy_ssl_certificate",
          "syntax": "proxy_ssl_certificate file;",
          "context": "http, server, location",
          "description": "\nSpecifies a file with the certificate in the PEM format\nused for authentication to a proxied HTTPS server.\n"
        },
        {
          "name": "proxy_ssl_certificate_key",
          "syntax": "proxy_ssl_certificate_key file;",
          "context": "http, server, location",
          "description": "\nSpecifies a file with the secret key in the PEM format\nused for authentication to a proxied HTTPS server.\n\n\nThe value\nengine:name:id\ncan be specified instead of the file (1.7.9),\nwhich loads a secret key with a specified id\nfrom the OpenSSL engine name.\n"
        },
        {
          "name": "proxy_ssl_ciphers",
          "syntax": "proxy_ssl_ciphers ciphers;",
          "default": "proxy_ssl_ciphers DEFAULT;",
          "context": "http, server, location",
          "description": "\nSpecifies the enabled ciphers for requests to a proxied HTTPS server.\nThe ciphers are specified in the format understood by the OpenSSL library.\n\n\nThe full list can be viewed using the\n“openssl ciphers” command.\n"
        },
        {
          "name": "proxy_ssl_crl",
          "syntax": "proxy_ssl_crl file;",
          "context": "http, server, location",
          "description": "\nSpecifies a file with revoked certificates (CRL)\nin the PEM format used to verify\nthe certificate of the proxied HTTPS server.\n"
        },
        {
          "name": "proxy_ssl_name",
          "syntax": "proxy_ssl_name name;",
          "default": "proxy_ssl_name $proxy_host;",
          "context": "http, server, location",
          "description": "\nAllows overriding the server name used to\nverify\nthe certificate of the proxied HTTPS server and to be\npassed through SNI\nwhen establishing a connection with the proxied HTTPS server.\n\n\nBy default, the host part of the proxy_pass URL is used.\n"
        },
        {
          "name": "proxy_ssl_password_file",
          "syntax": "proxy_ssl_password_file file;",
          "context": "http, server, location",
          "description": "\nSpecifies a file with passphrases for\nsecret keys\nwhere each passphrase is specified on a separate line.\nPassphrases are tried in turn when loading the key.\n"
        },
        {
          "name": "proxy_ssl_protocols",
          "syntax": "proxy_ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2] [TLSv1.3];",
          "default": "proxy_ssl_protocols TLSv1 TLSv1.1 TLSv1.2;",
          "context": "http, server, location",
          "description": "\nEnables the specified protocols for requests to a proxied HTTPS server.\n"
        },
        {
          "name": "proxy_ssl_server_name",
          "syntax": "proxy_ssl_server_name on | off;",
          "default": "proxy_ssl_server_name off;",
          "context": "http, server, location",
          "description": "\nEnables or disables passing of the server name through\nTLS\nServer Name Indication extension (SNI, RFC 6066)\nwhen establishing a connection with the proxied HTTPS server.\n"
        },
        {
          "name": "proxy_ssl_session_reuse",
          "syntax": "proxy_ssl_session_reuse on | off;",
          "default": "proxy_ssl_session_reuse on;",
          "context": "http, server, location",
          "description": "\nDetermines whether SSL sessions can be reused when working with\nthe proxied server.\nIf the errors\n“SSL3_GET_FINISHED:digest check failed”\nappear in the logs, try disabling session reuse.\n"
        },
        {
          "name": "proxy_ssl_trusted_certificate",
          "syntax": "proxy_ssl_trusted_certificate file;",
          "context": "http, server, location",
          "description": "\nSpecifies a file with trusted CA certificates in the PEM format\nused to verify\nthe certificate of the proxied HTTPS server.\n"
        },
        {
          "name": "proxy_ssl_verify",
          "syntax": "proxy_ssl_verify on | off;",
          "default": "proxy_ssl_verify off;",
          "context": "http, server, location",
          "description": "\nEnables or disables verification of the proxied HTTPS server certificate.\n"
        },
        {
          "name": "proxy_ssl_verify_depth",
          "syntax": "proxy_ssl_verify_depth number;",
          "default": "proxy_ssl_verify_depth 1;",
          "context": "http, server, location",
          "description": "\nSets the verification depth in the proxied HTTPS server certificates chain.\n"
        },
        {
          "name": "proxy_store",
          "syntax": "proxy_store on | off | string;",
          "default": "proxy_store off;",
          "context": "http, server, location",
          "description": "\nEnables saving of files to a disk.\nThe on parameter saves files with paths\ncorresponding to the directives\nalias or\nroot.\nThe off parameter disables saving of files.\nIn addition, the file name can be set explicitly using the\nstring with variables:\n\nproxy_store /data/www$original_uri;\n\n \n\n\nThe modification time of files is set according to the received\n“Last-Modified” response header field.\nThe response is first written to a temporary file,\nand then the file is renamed.\nStarting from version 0.8.9, temporary files and the persistent store\ncan be put on different file systems.\nHowever, be aware that in this case a file is copied\nacross two file systems instead of the cheap renaming operation.\nIt is thus recommended that for any given location both saved files and a\ndirectory holding temporary files, set by the proxy_temp_path\ndirective, are put on the same file system.\n\n\nThis directive can be used to create local copies of static unchangeable\nfiles, e.g.:\n\nlocation /images/ {\n    root               /data/www;\n    error_page         404 = /fetch$uri;\n}\n\nlocation /fetch/ {\n    internal;\n\n    proxy_pass         http://backend/;\n    proxy_store        on;\n    proxy_store_access user:rw group:rw all:r;\n    proxy_temp_path    /data/temp;\n\n    alias              /data/www/;\n}\n\n \n\n\nor like this:\n\nlocation /images/ {\n    root               /data/www;\n    error_page         404 = @fetch;\n}\n\nlocation @fetch {\n    internal;\n\n    proxy_pass         http://backend;\n    proxy_store        on;\n    proxy_store_access user:rw group:rw all:r;\n    proxy_temp_path    /data/temp;\n\n    root               /data/www;\n}\n\n \n"
        },
        {
          "name": "proxy_store_access",
          "syntax": "proxy_store_access users:permissions ...;",
          "default": "proxy_store_access user:rw;",
          "context": "http, server, location",
          "description": "\nSets access permissions for newly created files and directories, e.g.:\n\nproxy_store_access user:rw group:rw all:r;\n\n \n\n\nIf any group or all access permissions\nare specified then user permissions may be omitted:\n\nproxy_store_access group:rw all:r;\n\n \n"
        },
        {
          "name": "proxy_temp_file_write_size",
          "syntax": "proxy_temp_file_write_size size;",
          "default": "proxy_temp_file_write_size 8k|16k;",
          "context": "http, server, location",
          "description": "\nLimits the size of data written to a temporary file\nat a time, when buffering of responses from the proxied server\nto temporary files is enabled.\nBy default, size is limited by two buffers set by the\nproxy_buffer_size and proxy_buffers directives.\nThe maximum size of a temporary file is set by the\nproxy_max_temp_file_size directive.\n"
        },
        {
          "name": "proxy_temp_path",
          "syntax": "proxy_temp_path path [level1 [level2 [level3]]];",
          "default": "proxy_temp_path proxy_temp;",
          "context": "http, server, location",
          "description": "\nDefines a directory for storing temporary files\nwith data received from proxied servers.\nUp to three-level subdirectory hierarchy can be used underneath the specified\ndirectory.\nFor example, in the following configuration\n\nproxy_temp_path /spool/nginx/proxy_temp 1 2;\n\n \na temporary file might look like this:\n\n/spool/nginx/proxy_temp/7/45/00000123457\n\n \n\n\nSee also the use_temp_path parameter of the\nproxy_cache_path directive.\n"
        }
      ]
    },
    {
      "name": "ngx_http_realip_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_realip_module.html",
      "directives": [
        {
          "name": "set_real_ip_from",
          "syntax": "set_real_ip_from address | CIDR | unix:;",
          "context": "http, server, location",
          "description": "\nDefines trusted addresses that are known to send correct\nreplacement addresses.\nIf the special value unix: is specified,\nall UNIX-domain sockets will be trusted.\nTrusted addresses may also be specified using a hostname (1.13.1).\n\n\nIPv6 addresses are supported starting from versions 1.3.0 and 1.2.1.\n\n \n"
        },
        {
          "name": "real_ip_header",
          "syntax": "real_ip_header field | X-Real-IP | X-Forwarded-For | proxy_protocol;",
          "default": "real_ip_header X-Real-IP;",
          "context": "http, server, location",
          "description": "\nDefines the request header field\nwhose value will be used to replace the client address.\n\n\nThe request header field value that contains an optional port\nis also used to replace the client port (1.11.0).\nThe address and port should be specified according to\nRFC 3986.\n\n\nThe proxy_protocol parameter (1.5.12) changes\nthe client address to the one from the PROXY protocol header.\nThe PROXY protocol must be previously enabled by setting the\nproxy_protocol parameter\nin the listen directive.\n"
        },
        {
          "name": "real_ip_recursive",
          "syntax": "real_ip_recursive on | off;",
          "default": "real_ip_recursive off;",
          "context": "http, server, location",
          "description": "\nIf recursive search is disabled, the original client address that\nmatches one of the trusted addresses is replaced by the last\naddress sent in the request header field defined by the\nreal_ip_header directive.\nIf recursive search is enabled, the original client address that\nmatches one of the trusted addresses is replaced by the last\nnon-trusted address sent in the request header field.\n"
        }
      ]
    },
    {
      "name": "ngx_http_referer_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_referer_module.html",
      "directives": [
        {
          "name": "referer_hash_bucket_size",
          "syntax": "referer_hash_bucket_size size;",
          "default": "referer_hash_bucket_size 64;",
          "context": "server, location",
          "description": "\nSets the bucket size for the valid referers hash tables.\nThe details of setting up hash tables are provided in a separate\ndocument.\n"
        },
        {
          "name": "referer_hash_max_size",
          "syntax": "referer_hash_max_size size;",
          "default": "referer_hash_max_size 2048;",
          "context": "server, location",
          "description": "\nSets the maximum size of the valid referers hash tables.\nThe details of setting up hash tables are provided in a separate\ndocument.\n"
        },
        {
          "name": "valid_referers",
          "syntax": "valid_referers none | blocked | server_names | string ...;",
          "context": "server, location",
          "description": "\nSpecifies the “Referer” request header field values\nthat will cause the embedded $invalid_referer variable to\nbe set to an empty string.\nOtherwise, the variable will be set to “1”.\nSearch for a match is case-insensitive.\n\n\nParameters can be as follows:\n\n\n\nnone\n\nthe “Referer” field is missing in the request header;\n\n\nblocked\n\nthe “Referer” field is present in the request header,\nbut its value has been deleted by a firewall or proxy server;\nsuch values are strings that do not start with\n“http://” or “https://”;\n\n\nserver_names\n\nthe “Referer” request header field contains\none of the server names;\n\n\narbitrary string\n\ndefines a server name and an optional URI prefix.\nA server name can have an “*” at the beginning or end.\nDuring the checking, the server’s port in the “Referer” field\nis ignored;\n\n\nregular expression\n\nthe first symbol should be a “~”.\nIt should be noted that an expression will be matched against\nthe text starting after the “http://”\nor “https://”.\n\n\n\n \n\n\nExample:\n\nvalid_referers none blocked server_names\n               *.example.com example.* www.example.org/galleries/\n               ~\\.google\\.;\n\n \n"
        }
      ]
    },
    {
      "name": "ngx_http_rewrite_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_rewrite_module.html",
      "directives": [
        {
          "name": "break;",
          "syntax": "break;",
          "context": "server, location, if",
          "description": "\nStops processing the current set of\nngx_http_rewrite_module directives.\n\n\nIf a directive is specified inside the\nlocation,\nfurther processing of the request continues in this location.\n\n\nExample:\n\nif ($slow) {\n    limit_rate 10k;\n    break;\n}\n\n \n"
        },
        {
          "name": "if",
          "syntax": "if (condition) { ... }",
          "context": "server, location",
          "description": "\nThe specified condition is evaluated.\nIf true, this module directives specified inside the braces are\nexecuted, and the request is assigned the configuration inside the\nif directive.\nConfigurations inside the if directives are\ninherited from the previous configuration level.\n\n\nA condition may be any of the following:\n\n\n\n\na variable name; false if the value of a variable is an empty string\nor “0”;\n\nBefore version 1.0.1, any string starting with “0”\nwas considered a false value.\n\n\n\n\ncomparison of a variable with a string using the\n“=” and “!=” operators;\n\n\n\nmatching of a variable against a regular expression using the\n“~” (for case-sensitive matching) and\n“~*” (for case-insensitive matching) operators.\nRegular expressions can contain captures that are made available for\nlater reuse in the $1..$9 variables.\nNegative operators “!~” and “!~*”\nare also available.\nIf a regular expression includes the “}”\nor “;” characters, the whole expressions should be enclosed\nin single or double quotes.\n\n\n\nchecking of a file existence with the “-f” and\n“!-f” operators;\n\n\n\nchecking of a directory existence with the “-d” and\n“!-d” operators;\n\n\n\nchecking of a file, directory, or symbolic link existence with the\n“-e” and “!-e” operators;\n\n\n\nchecking for an executable file with the “-x”\nand “!-x” operators.\n\n\n\n \n\n\nExamples:\n\nif ($http_user_agent ~ MSIE) {\n    rewrite ^(.*)$ /msie/$1 break;\n}\n\nif ($http_cookie ~* \"id=([^;]+)(?:;|$)\") {\n    set $id $1;\n}\n\nif ($request_method = POST) {\n    return 405;\n}\n\nif ($slow) {\n    limit_rate 10k;\n}\n\nif ($invalid_referer) {\n    return 403;\n}\n\n \n\n\nA value of the $invalid_referer embedded variable is set by the\nvalid_referers directive.\n\n \n"
        },
        {
          "name": "return",
          "syntax": "return code [text];return code URL;return URL;",
          "context": "server, location, if",
          "description": "\nStops processing and returns the specified code to a client.\nThe non-standard code 444 closes a connection without sending\na response header.\n\n\nStarting from version 0.8.42, it is possible to specify\neither a redirect URL (for codes 301, 302, 303, 307, and 308)\nor the response body text (for other codes).\nA response body text and redirect URL can contain variables.\nAs a special case, a redirect URL can be specified as a URI\nlocal to this server, in which case the full redirect URL\nis formed according to the request scheme ($scheme) and the\nserver_name_in_redirect and\nport_in_redirect directives.\n\n\nIn addition, a URL for temporary redirect with the code 302\ncan be specified as the sole parameter.\nSuch a parameter should start with the “http://”,\n“https://”, or “$scheme” string.\nA URL can contain variables.\n\n\n\n\nOnly the following codes could be returned before version 0.7.51:\n204, 400, 402 — 406, 408, 410, 411, 413, 416, and 500 — 504.\n\n \n\n\n\nThe code 307 was not treated as a redirect until versions 1.1.16 and 1.0.13.\n\n \n\n\n\nThe code 308 was not treated as a redirect until version 1.13.0.\n\n \n\n\nSee also the error_page directive.\n"
        },
        {
          "name": "rewrite",
          "syntax": "rewrite regex replacement [flag];",
          "context": "server, location, if",
          "description": "\nIf the specified regular expression matches a request URI, URI is changed\nas specified in the replacement string.\nThe rewrite directives are executed sequentially\nin order of their appearance in the configuration file.\nIt is possible to terminate further processing of the directives using flags.\nIf a replacement string starts with “http://”,\n“https://”, or “$scheme”,\nthe processing stops and the redirect is returned to a client.\n\n\nAn optional flag parameter can be one of:\n\n\n\nlast\n\nstops processing the current set of\nngx_http_rewrite_module directives and starts\na search for a new location matching the changed URI;\n\n\nbreak\n\nstops processing the current set of\nngx_http_rewrite_module directives\nas with the break directive;\n\n\nredirect\n\nreturns a temporary redirect with the 302 code;\nused if a replacement string does not start with\n“http://”, “https://”,\nor “$scheme”;\n\n\npermanent\n\nreturns a permanent redirect with the 301 code.\n\n\n\n \nThe full redirect URL is formed according to the\nrequest scheme ($scheme) and the\nserver_name_in_redirect and\nport_in_redirect directives.\n\n\nExample:\n\nserver {\n    ...\n    rewrite ^(/download/.*)/media/(.*)\\..*$ $1/mp3/$2.mp3 last;\n    rewrite ^(/download/.*)/audio/(.*)\\..*$ $1/mp3/$2.ra  last;\n    return  403;\n    ...\n}\n\n \n\n\nBut if these directives are put inside the “/download/”\nlocation, the last flag should be replaced by\nbreak, or otherwise nginx will make 10 cycles and\nreturn the 500 error:\n\nlocation /download/ {\n    rewrite ^(/download/.*)/media/(.*)\\..*$ $1/mp3/$2.mp3 break;\n    rewrite ^(/download/.*)/audio/(.*)\\..*$ $1/mp3/$2.ra  break;\n    return  403;\n}\n\n \n\n\nIf a replacement string includes the new request arguments,\nthe previous request arguments are appended after them.\nIf this is undesired, putting a question mark at the end of a replacement\nstring avoids having them appended, for example:\n\nrewrite ^/users/(.*)$ /show?user=$1? last;\n\n \n\n\nIf a regular expression includes the “}”\nor “;” characters, the whole expressions should be enclosed\nin single or double quotes.\n"
        },
        {
          "name": "rewrite_log",
          "syntax": "rewrite_log on | off;",
          "default": "rewrite_log off;",
          "context": "http, server, location, if",
          "description": "\nEnables or disables logging of ngx_http_rewrite_module\nmodule directives processing results\ninto the error_log at\nthe notice level.\n"
        },
        {
          "name": "set",
          "syntax": "set $variable value;",
          "context": "server, location, if",
          "description": "\nSets a value for the specified variable.\nThe value can contain text, variables, and their combination.\n"
        },
        {
          "name": "uninitialized_variable_warn",
          "syntax": "uninitialized_variable_warn on | off;",
          "default": "uninitialized_variable_warn on;",
          "context": "http, server, location, if",
          "description": "\nControls whether warnings about uninitialized variables are logged.\n"
        }
      ]
    },
    {
      "name": "ngx_http_split_clients_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_split_clients_module.html",
      "directives": [
        {
          "name": "split_clients",
          "syntax": "split_clients string $variable { ... }",
          "context": "http",
          "description": "\nCreates a variable for A/B testing, for example:\n\nsplit_clients \"${remote_addr}AAA\" $variant {\n               0.5%               .one;\n               2.0%               .two;\n               *                  \"\";\n}\n\n \nThe value of the original string is hashed using MurmurHash2.\nIn the example given, hash values from 0 to 21474835 (0.5%)\ncorrespond to the\nvalue \".one\" of the $variant variable,\nhash values from 21474836 to 107374180 (2%) correspond to\nthe value \".two\",\nand hash values from 107374181 to 4294967295 correspond to\nthe value \"\" (an empty string).\n"
        }
      ]
    },
    {
      "name": "ngx_http_ssl_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_ssl_module.html",
      "directives": [
        {
          "name": "ssl",
          "syntax": "ssl on | off;",
          "default": "ssl off;",
          "context": "http, server",
          "description": "\nThis directive was made obsolete in version 1.15.0.\nThe ssl parameter\nof the listen directive\nshould be used instead.\n"
        },
        {
          "name": "ssl_buffer_size",
          "syntax": "ssl_buffer_size size;",
          "default": "ssl_buffer_size 16k;",
          "context": "http, server",
          "description": "\nSets the size of the buffer used for sending data.\n\n\nBy default, the buffer size is 16k, which corresponds to minimal\noverhead when sending big responses.\nTo minimize Time To First Byte it may be beneficial to use smaller values,\nfor example:\n\nssl_buffer_size 4k;\n\n \n"
        },
        {
          "name": "ssl_certificate",
          "syntax": "ssl_certificate file;",
          "context": "http, server",
          "description": "\nSpecifies a file with the certificate in the PEM format\nfor the given virtual server.\nIf intermediate certificates should be specified in addition to a primary\ncertificate, they should be specified in the same file in the following\norder: the primary certificate comes first, then the intermediate certificates.\nA secret key in the PEM format may be placed in the same file.\n\n\nSince version 1.11.0,\nthis directive can be specified multiple times\nto load certificates of different types, for example, RSA and ECDSA:\n\nserver {\n    listen              443 ssl;\n    server_name         example.com;\n\n    ssl_certificate     example.com.rsa.crt;\n    ssl_certificate_key example.com.rsa.key;\n\n    ssl_certificate     example.com.ecdsa.crt;\n    ssl_certificate_key example.com.ecdsa.key;\n\n    ...\n}\n\n \n\n\nOnly OpenSSL 1.0.2 or higher supports separate\ncertificate chains\nfor different certificates.\nWith older versions, only one certificate chain can be used.\n\n \n\n\nSince version 1.15.9, variables can be used in the file name\nwhen using OpenSSL 1.0.2 or higher:\n\nssl_certificate     $ssl_server_name.crt;\nssl_certificate_key $ssl_server_name.key;\n\n \nNote that using variables implies that\na certificate will be loaded for each SSL handshake,\nand this may have a negative impact on performance.\n"
        },
        {
          "name": "ssl_certificate_key",
          "syntax": "ssl_certificate_key file;",
          "context": "http, server",
          "description": "\nSpecifies a file with the secret key in the PEM format\nfor the given virtual server.\n\n\nThe value\nengine:name:id\ncan be specified instead of the file (1.7.9),\nwhich loads a secret key with a specified id\nfrom the OpenSSL engine name.\n"
        },
        {
          "name": "ssl_ciphers",
          "syntax": "ssl_ciphers ciphers;",
          "default": "ssl_ciphers HIGH:!aNULL:!MD5;",
          "context": "http, server",
          "description": "\nSpecifies the enabled ciphers.\nThe ciphers are specified in the format understood by the\nOpenSSL library, for example:\n\nssl_ciphers ALL:!aNULL:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;\n\n \n\n\nThe full list can be viewed using the\n“openssl ciphers” command.\n\n\n\n\nThe previous versions of nginx used\ndifferent\nciphers by default.\n\n \n"
        },
        {
          "name": "ssl_client_certificate",
          "syntax": "ssl_client_certificate file;",
          "context": "http, server",
          "description": "\nSpecifies a file with trusted CA certificates in the PEM format\nused to verify client certificates and\nOCSP responses if ssl_stapling is enabled.\n\n\nThe list of certificates will be sent to clients.\nIf this is not desired, the ssl_trusted_certificate\ndirective can be used.\n"
        },
        {
          "name": "ssl_crl",
          "syntax": "ssl_crl file;",
          "context": "http, server",
          "description": "\nSpecifies a file with revoked certificates (CRL)\nin the PEM format used to verify\nclient certificates.\n"
        },
        {
          "name": "ssl_dhparam",
          "syntax": "ssl_dhparam file;",
          "context": "http, server",
          "description": "\nSpecifies a file with DH parameters for DHE ciphers.\n\n\nBy default no parameters are set,\nand therefore DHE ciphers will not be used.\n\n\nPrior to version 1.11.0, builtin parameters were used by default.\n\n \n"
        },
        {
          "name": "ssl_early_data",
          "syntax": "ssl_early_data on | off;",
          "default": "ssl_early_data off;",
          "context": "http, server",
          "description": "\nEnables or disables TLS 1.3\nearly data.\n\n\nRequests sent within early data are subject to\nreplay attacks.\nTo protect against such attacks at the application layer,\nthe $ssl_early_data variable\nshould be used.\n\n \n\n\nproxy_set_header Early-Data $ssl_early_data;\n\n \n\n\n\nThe directive is supported when using OpenSSL 1.1.1 or higher (1.15.4) and\nBoringSSL.\n\n \n"
        },
        {
          "name": "ssl_ecdh_curve",
          "syntax": "ssl_ecdh_curve curve;",
          "default": "ssl_ecdh_curve auto;",
          "context": "http, server",
          "description": "\nSpecifies a curve for ECDHE ciphers.\n\n\nWhen using OpenSSL 1.0.2 or higher,\nit is possible to specify multiple curves (1.11.0), for example:\n\nssl_ecdh_curve prime256v1:secp384r1;\n\n \n\n\nThe special value auto (1.11.0) instructs nginx to use\na list built into the OpenSSL library when using OpenSSL 1.0.2 or higher,\nor prime256v1 with older versions.\n\n\n\n\nPrior to version 1.11.0,\nthe prime256v1 curve was used by default.\n\n \n"
        },
        {
          "name": "ssl_password_file",
          "syntax": "ssl_password_file file;",
          "context": "http, server",
          "description": "\nSpecifies a file with passphrases for\nsecret keys\nwhere each passphrase is specified on a separate line.\nPassphrases are tried in turn when loading the key.\n\n\nExample:\n\nhttp {\n    ssl_password_file /etc/keys/global.pass;\n    ...\n\n    server {\n        server_name www1.example.com;\n        ssl_certificate_key /etc/keys/first.key;\n    }\n\n    server {\n        server_name www2.example.com;\n\n        # named pipe can also be used instead of a file\n        ssl_password_file /etc/keys/fifo;\n        ssl_certificate_key /etc/keys/second.key;\n    }\n}\n\n \n"
        },
        {
          "name": "ssl_prefer_server_ciphers",
          "syntax": "ssl_prefer_server_ciphers on | off;",
          "default": "ssl_prefer_server_ciphers off;",
          "context": "http, server",
          "description": "\nSpecifies that server ciphers should be preferred over client\nciphers when using the SSLv3 and TLS protocols.\n"
        },
        {
          "name": "ssl_protocols",
          "syntax": "ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2] [TLSv1.3];",
          "default": "ssl_protocols TLSv1 TLSv1.1 TLSv1.2;",
          "context": "http, server",
          "description": "\nEnables the specified protocols.\n\n\nThe TLSv1.1 and TLSv1.2 parameters\n(1.1.13, 1.0.12) work only when OpenSSL 1.0.1 or higher is used.\n\n \n\n\nThe TLSv1.3 parameter (1.13.0) works only when\nOpenSSL 1.1.1 built with TLSv1.3 support is used.\n\n \n"
        },
        {
          "name": "ssl_session_cache",
          "syntax": "ssl_session_cache off | none | [builtin[:size]] [shared:name:size];",
          "default": "ssl_session_cache none;",
          "context": "http, server",
          "description": "\nSets the types and sizes of caches that store session parameters.\nA cache can be of any of the following types:\n\n\n\noff\n\nthe use of a session cache is strictly prohibited:\nnginx explicitly tells a client that sessions may not be reused.\n\n\nnone\n\nthe use of a session cache is gently disallowed:\nnginx tells a client that sessions may be reused, but does not\nactually store session parameters in the cache.\n\n\nbuiltin\n\na cache built in OpenSSL; used by one worker process only.\nThe cache size is specified in sessions.\nIf size is not given, it is equal to 20480 sessions.\nUse of the built-in cache can cause memory fragmentation.\n\n\nshared\n\na cache shared between all worker processes.\nThe cache size is specified in bytes; one megabyte can store\nabout 4000 sessions.\nEach shared cache should have an arbitrary name.\nA cache with the same name can be used in several virtual servers.\n\n\n\n \n\n\nBoth cache types can be used simultaneously, for example:\n\nssl_session_cache builtin:1000 shared:SSL:10m;\n\n \nbut using only shared cache without the built-in cache should\nbe more efficient.\n"
        },
        {
          "name": "ssl_session_ticket_key",
          "syntax": "ssl_session_ticket_key file;",
          "context": "http, server",
          "description": "\nSets a file with the secret key used to encrypt\nand decrypt TLS session tickets.\nThe directive is necessary if the same key has to be shared between\nmultiple servers.\nBy default, a randomly generated key is used.\n\n\nIf several keys are specified, only the first key is\nused to encrypt TLS session tickets.\nThis allows configuring key rotation, for example:\n\nssl_session_ticket_key current.key;\nssl_session_ticket_key previous.key;\n\n \n\n\nThe file must contain 80 or 48 bytes\nof random data and can be created using the following command:\n\nopenssl rand 80 > ticket.key\n\n \nDepending on the file size either AES256 (for 80-byte keys, 1.11.8)\nor AES128 (for 48-byte keys) is used for encryption.\n"
        },
        {
          "name": "ssl_session_tickets",
          "syntax": "ssl_session_tickets on | off;",
          "default": "ssl_session_tickets on;",
          "context": "http, server",
          "description": "\nEnables or disables session resumption through\nTLS session tickets.\n"
        },
        {
          "name": "ssl_session_timeout",
          "syntax": "ssl_session_timeout time;",
          "default": "ssl_session_timeout 5m;",
          "context": "http, server",
          "description": "\nSpecifies a time during which a client may reuse the\nsession parameters.\n"
        },
        {
          "name": "ssl_stapling",
          "syntax": "ssl_stapling on | off;",
          "default": "ssl_stapling off;",
          "context": "http, server",
          "description": "\nEnables or disables\nstapling\nof OCSP responses by the server.\nExample:\n\nssl_stapling on;\nresolver 192.0.2.1;\n\n \n\n\nFor the OCSP stapling to work, the certificate of the server certificate\nissuer should be known.\nIf the ssl_certificate file does\nnot contain intermediate certificates,\nthe certificate of the server certificate issuer should be\npresent in the\nssl_trusted_certificate file.\n\n\nFor a resolution of the OCSP responder hostname,\nthe resolver directive\nshould also be specified.\n"
        },
        {
          "name": "ssl_stapling_file",
          "syntax": "ssl_stapling_file file;",
          "context": "http, server",
          "description": "\nWhen set, the stapled OCSP response will be taken from the\nspecified file instead of querying\nthe OCSP responder specified in the server certificate.\n\n\nThe file should be in the DER format as produced by the\n“openssl ocsp” command.\n"
        },
        {
          "name": "ssl_stapling_responder",
          "syntax": "ssl_stapling_responder url;",
          "context": "http, server",
          "description": "\nOverrides the URL of the OCSP responder specified in the\n“Authority\nInformation Access” certificate extension.\n\n\nOnly “http://” OCSP responders are supported:\n\nssl_stapling_responder http://ocsp.example.com/;\n\n \n"
        },
        {
          "name": "ssl_stapling_verify",
          "syntax": "ssl_stapling_verify on | off;",
          "default": "ssl_stapling_verify off;",
          "context": "http, server",
          "description": "\nEnables or disables verification of OCSP responses by the server.\n\n\nFor verification to work, the certificate of the server certificate\nissuer, the root certificate, and all intermediate certificates\nshould be configured as trusted using the\nssl_trusted_certificate directive.\n"
        },
        {
          "name": "ssl_trusted_certificate",
          "syntax": "ssl_trusted_certificate file;",
          "context": "http, server",
          "description": "\nSpecifies a file with trusted CA certificates in the PEM format\nused to verify client certificates and\nOCSP responses if ssl_stapling is enabled.\n\n\nIn contrast to the certificate set by ssl_client_certificate,\nthe list of these certificates will not be sent to clients.\n"
        },
        {
          "name": "ssl_verify_client",
          "syntax": "ssl_verify_client on | off | optional | optional_no_ca;",
          "default": "ssl_verify_client off;",
          "context": "http, server",
          "description": "\nEnables verification of client certificates.\nThe verification result is stored in the\n$ssl_client_verify variable.\n\n\nThe optional parameter (0.8.7+) requests the client\ncertificate and verifies it if the certificate is present.\n\n\nThe optional_no_ca parameter (1.3.8, 1.2.5)\nrequests the client\ncertificate but does not require it to be signed by a trusted CA certificate.\nThis is intended for the use in cases when a service that is external to nginx\nperforms the actual certificate verification.\nThe contents of the certificate is accessible through the\n$ssl_client_cert variable.\n"
        },
        {
          "name": "ssl_verify_depth",
          "syntax": "ssl_verify_depth number;",
          "default": "ssl_verify_depth 1;",
          "context": "http, server",
          "description": "\nSets the verification depth in the client certificates chain.\n"
        }
      ]
    },
    {
      "name": "ngx_http_status_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_status_module.html",
      "directives": [
        {
          "name": "status;",
          "syntax": "status;",
          "context": "location",
          "description": "\nThe status information will be accessible from the surrounding location.\nAccess to this location should be\nlimited.\n"
        },
        {
          "name": "status_format",
          "syntax": "status_format json;status_format jsonp [callback];",
          "default": "status_format json;",
          "context": "http, server, location",
          "description": "\nBy default, status information is output in the JSON format.\n\n\nAlternatively, data may be output as JSONP.\nThe callback parameter specifies the name of a callback function.\nParameter value can contain variables.\nIf parameter is omitted, or the computed value is an empty string,\nthen “ngx_status_jsonp_callback” is used.\n"
        },
        {
          "name": "status_zone",
          "syntax": "status_zone zone;",
          "context": "server",
          "description": "\nEnables collection of virtual\nhttp\nor\nstream\n(1.7.11) server status information in the specified zone.\nSeveral servers may share the same zone.\n"
        }
      ]
    },
    {
      "name": "ngx_http_stub_status_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_stub_status_module.html",
      "directives": [
        {
          "name": "stub_status;",
          "syntax": "stub_status;",
          "context": "server, location",
          "description": "\nThe basic status information will be accessible from the surrounding location.\n\n\n\n\nIn versions prior to 1.7.5,\nthe directive syntax required an arbitrary argument, for example,\n“stub_status on”.\n\n \n"
        }
      ]
    },
    {
      "name": "ngx_http_sub_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_sub_module.html",
      "directives": [
        {
          "name": "sub_filter",
          "syntax": "sub_filter string replacement;",
          "context": "http, server, location",
          "description": "\nSets a string to replace and a replacement string.\nThe string to replace is matched ignoring the case.\nThe string to replace (1.9.4) and replacement string can contain variables.\nSeveral sub_filter directives\ncan be specified on one configuration level (1.9.4).\nThese directives are inherited from the previous level if and only if there are\nno sub_filter directives defined on the current level.\n"
        },
        {
          "name": "sub_filter_last_modified",
          "syntax": "sub_filter_last_modified on | off;",
          "default": "sub_filter_last_modified off;",
          "context": "http, server, location",
          "description": "\nAllows preserving the “Last-Modified” header field\nfrom the original response during replacement\nto facilitate response caching.\n\n\nBy default, the header field is removed as contents of the response\nare modified during processing.\n"
        },
        {
          "name": "sub_filter_once",
          "syntax": "sub_filter_once on | off;",
          "default": "sub_filter_once on;",
          "context": "http, server, location",
          "description": "\nIndicates whether to look for each string to replace\nonce or repeatedly.\n"
        },
        {
          "name": "sub_filter_types",
          "syntax": "sub_filter_types mime-type ...;",
          "default": "sub_filter_types text/html;",
          "context": "http, server, location",
          "description": "\nEnables string replacement in responses with the specified MIME types\nin addition to “text/html”.\nThe special value “*” matches any MIME type (0.8.29).\n"
        }
      ]
    },
    {
      "name": "ngx_http_userid_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_userid_module.html",
      "directives": [
        {
          "name": "userid",
          "syntax": "userid on | v1 | log | off;",
          "default": "userid off;",
          "context": "http, server, location",
          "description": "\nEnables or disables setting cookies and logging the received cookies:\n\n\n\non\n\nenables the setting of version 2 cookies\nand logging of the received cookies;\n\n\nv1\n\nenables the setting of version 1 cookies\nand logging of the received cookies;\n\n\nlog\n\ndisables the setting of cookies,\nbut enables logging of the received cookies;\n\n\noff\n\ndisables the setting of cookies and logging of the received cookies.\n\n\n\n \n"
        },
        {
          "name": "userid_domain",
          "syntax": "userid_domain name | none;",
          "default": "userid_domain none;",
          "context": "http, server, location",
          "description": "\nDefines a domain for which the cookie is set.\nThe none parameter disables setting of a domain for the\ncookie.\n"
        },
        {
          "name": "userid_expires",
          "syntax": "userid_expires time | max | off;",
          "default": "userid_expires off;",
          "context": "http, server, location",
          "description": "\nSets a time during which a browser should keep the cookie.\nThe parameter max will cause the cookie to expire on\n“31 Dec 2037 23:55:55 GMT”.\nThe parameter off will cause the cookie to expire at\nthe end of a browser session.\n"
        },
        {
          "name": "userid_mark",
          "syntax": "userid_mark letter | digit | = | off;",
          "default": "userid_mark off;",
          "context": "http, server, location",
          "description": "\nIf the parameter is not off, enables the cookie marking\nmechanism and sets the character used as a mark.\nThis mechanism is used to add or change\nuserid_p3p and/or a cookie expiration time while\npreserving the client identifier.\nA mark can be any letter of the English alphabet (case-sensitive),\ndigit, or the “=” character.\n\n\nIf the mark is set, it is compared with the first padding symbol\nin the base64 representation of the client identifier passed in a cookie.\nIf they do not match, the cookie is resent with the specified mark,\nexpiration time, and “P3P” header.\n"
        },
        {
          "name": "userid_name",
          "syntax": "userid_name name;",
          "default": "userid_name uid;",
          "context": "http, server, location",
          "description": "\nSets the cookie name.\n"
        },
        {
          "name": "userid_p3p",
          "syntax": "userid_p3p string | none;",
          "default": "userid_p3p none;",
          "context": "http, server, location",
          "description": "\nSets a value for the “P3P” header field that will be\nsent along with the cookie.\nIf the directive is set to the special value none,\nthe “P3P” header will not be sent in a response.\n"
        },
        {
          "name": "userid_path",
          "syntax": "userid_path path;",
          "default": "userid_path /;",
          "context": "http, server, location",
          "description": "\nDefines a path for which the cookie is set.\n"
        },
        {
          "name": "userid_service",
          "syntax": "userid_service number;",
          "default": "userid_service IP address of the server;",
          "context": "http, server, location",
          "description": "\nIf identifiers are issued by multiple servers (services),\neach service should be assigned its own number\nto ensure that client identifiers are unique.\nFor version 1 cookies, the default value is zero.\nFor version 2 cookies, the default value is the number composed from the last\nfour octets of the server’s IP address.\n"
        }
      ]
    },
    {
      "name": "ngx_http_v2_module",
      "link": "https://nginx.org/en/docs/http/ngx_http_v2_module.html",
      "directives": [
        {
          "name": "http2_body_preread_size",
          "syntax": "http2_body_preread_size size;",
          "default": "http2_body_preread_size 64k;",
          "context": "http, server",
          "description": "\nSets the size of the buffer per each request\nin which the request body may be saved\nbefore it is started to be processed.\n"
        },
        {
          "name": "http2_chunk_size",
          "syntax": "http2_chunk_size size;",
          "default": "http2_chunk_size 8k;",
          "context": "http, server, location",
          "description": "\nSets the maximum size of chunks\ninto which the response body is sliced.\nA too low value results in higher overhead.\nA too high value impairs prioritization due to\n\nHOL blocking.\n"
        },
        {
          "name": "http2_idle_timeout",
          "syntax": "http2_idle_timeout time;",
          "default": "http2_idle_timeout 3m;",
          "context": "http, server",
          "description": "\nSets the timeout of inactivity after which the connection is closed.\n"
        },
        {
          "name": "http2_max_concurrent_pushes",
          "syntax": "http2_max_concurrent_pushes number;",
          "default": "http2_max_concurrent_pushes 10;",
          "context": "http, server",
          "description": "\nLimits the maximum number of concurrent\npush requests in a connection.\n"
        },
        {
          "name": "http2_max_concurrent_streams",
          "syntax": "http2_max_concurrent_streams number;",
          "default": "http2_max_concurrent_streams 128;",
          "context": "http, server",
          "description": "\nSets the maximum number of concurrent HTTP/2 streams\nin a connection.\n"
        },
        {
          "name": "http2_max_field_size",
          "syntax": "http2_max_field_size size;",
          "default": "http2_max_field_size 4k;",
          "context": "http, server",
          "description": "\nLimits the maximum size of\nan HPACK-compressed\nrequest header field.\nThe limit applies equally to both name and value.\nNote that if Huffman encoding is applied,\nthe actual size of decompressed name and value strings may be larger.\nFor most requests, the default limit should be enough.\n"
        },
        {
          "name": "http2_max_header_size",
          "syntax": "http2_max_header_size size;",
          "default": "http2_max_header_size 16k;",
          "context": "http, server",
          "description": "\nLimits the maximum size of the entire request header list after\nHPACK decompression.\nFor most requests, the default limit should be enough.\n"
        },
        {
          "name": "http2_max_requests",
          "syntax": "http2_max_requests number;",
          "default": "http2_max_requests 1000;",
          "context": "http, server",
          "description": "\nSets the maximum number of requests (including\npush requests) that can be served\nthrough one HTTP/2 connection,\nafter which the next client request will lead to connection closing\nand the need of establishing a new connection.\n"
        },
        {
          "name": "http2_push",
          "syntax": "http2_push uri | off;",
          "default": "http2_push off;",
          "context": "http, server, location",
          "description": "\nPre-emptively sends\n(pushes)\na request to the specified uri\nalong with the response to the original request.\nOnly relative URIs with absolute path will be processed,\nfor example:\n\nhttp2_push /static/css/main.css;\n\n \nThe uri value can contain variables.\n\n\nSeveral http2_push directives\ncan be specified on the same configuration level.\nThe off parameter cancels the effect\nof the http2_push directives\ninherited from the previous configuration level.\n"
        },
        {
          "name": "http2_push_preload",
          "syntax": "http2_push_preload on | off;",
          "default": "http2_push_preload off;",
          "context": "http, server, location",
          "description": "\nEnables automatic conversion of\npreload\nlinks\nspecified in the “Link” response header fields into\npush\nrequests.\n"
        },
        {
          "name": "http2_recv_buffer_size",
          "syntax": "http2_recv_buffer_size size;",
          "default": "http2_recv_buffer_size 256k;",
          "context": "http",
          "description": "\nSets the size of the per\nworker\ninput buffer.\n"
        },
        {
          "name": "http2_recv_timeout",
          "syntax": "http2_recv_timeout time;",
          "default": "http2_recv_timeout 30s;",
          "context": "http, server",
          "description": "\nSets the timeout for expecting more data from the client,\nafter which the connection is closed.\n"
        }
      ]
    },
    {
      "name": "ngx_stream_core_module",
      "link": "https://nginx.org/en/docs/stream/ngx_stream_core_module.html",
      "directives": [
        {
          "name": "listen",
          "syntax": "listen address:port [ssl] [udp] [proxy_protocol] [backlog=number] [rcvbuf=size] [sndbuf=size] [bind] [ipv6only=on|off] [reuseport] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];",
          "context": "server",
          "description": "\nSets the address and port for the socket\non which the server will accept connections.\nIt is possible to specify just the port.\nThe address can also be a hostname, for example:\n\nlisten 127.0.0.1:12345;\nlisten *:12345;\nlisten 12345;     # same as *:12345\nlisten localhost:12345;\n\n \nIPv6 addresses are specified in square brackets:\n\nlisten [::1]:12345;\nlisten [::]:12345;\n\n \nUNIX-domain sockets are specified with the “unix:”\nprefix:\n\nlisten unix:/var/run/nginx.sock;\n\n \n"
        },
        {
          "name": "preread_buffer_size",
          "syntax": "preread_buffer_size size;",
          "default": "preread_buffer_size 16k;",
          "context": "stream, server",
          "description": "\nSpecifies a size of the\npreread buffer.\n"
        },
        {
          "name": "preread_timeout",
          "syntax": "preread_timeout timeout;",
          "default": "preread_timeout 30s;",
          "context": "stream, server",
          "description": "\nSpecifies a timeout of the\npreread phase.\n"
        },
        {
          "name": "proxy_protocol_timeout",
          "syntax": "proxy_protocol_timeout timeout;",
          "default": "proxy_protocol_timeout 30s;",
          "context": "stream, server",
          "description": "\nSpecifies a timeout for\nreading the PROXY protocol header to complete.\nIf no entire header is transmitted within this time,\nthe connection is closed.\n"
        },
        {
          "name": "server",
          "syntax": "server { ... }",
          "context": "stream",
          "description": "\nSets the configuration for a server.\n"
        },
        {
          "name": "stream",
          "syntax": "stream { ... }",
          "context": "main",
          "description": "\nProvides the configuration file context in which the stream server directives\nare specified.\n"
        },
        {
          "name": "tcp_nodelay",
          "syntax": "tcp_nodelay on | off;",
          "default": "tcp_nodelay on;",
          "context": "stream, server",
          "description": "\nEnables or disables the use of the TCP_NODELAY option.\nThe option is enabled for both client and proxied server connections.\n"
        },
        {
          "name": "variables_hash_bucket_size",
          "syntax": "variables_hash_bucket_size size;",
          "default": "variables_hash_bucket_size 64;",
          "context": "stream",
          "description": "\nSets the bucket size for the variables hash table.\nThe details of setting up hash tables are provided in a separate\ndocument.\n"
        },
        {
          "name": "variables_hash_max_size",
          "syntax": "variables_hash_max_size size;",
          "default": "variables_hash_max_size 1024;",
          "context": "stream",
          "description": "\nSets the maximum size of the variables hash table.\nThe details of setting up hash tables are provided in a separate\ndocument.\n"
        }
      ]
    },
    {
      "name": "ngx_stream_access_module",
      "link": "https://nginx.org/en/docs/stream/ngx_stream_access_module.html",
      "directives": [
        {
          "name": "allow",
          "syntax": "allow address | CIDR | unix: | all;",
          "context": "stream, server",
          "description": "\nAllows access for the specified network or address.\nIf the special value unix: is specified,\nallows access for all UNIX-domain sockets.\n"
        },
        {
          "name": "deny",
          "syntax": "deny address | CIDR | unix: | all;",
          "context": "stream, server",
          "description": "\nDenies access for the specified network or address.\nIf the special value unix: is specified,\ndenies access for all UNIX-domain sockets.\n"
        }
      ]
    },
    {
      "name": "ngx_stream_geo_module",
      "link": "https://nginx.org/en/docs/stream/ngx_stream_geo_module.html",
      "directives": [
        {
          "name": "geo",
          "syntax": "geo [$address] $variable { ... }",
          "context": "stream",
          "description": "\nDescribes the dependency of values of the specified variable\non the client IP address.\nBy default, the address is taken from the $remote_addr variable,\nbut it can also be taken from another variable, for example:\n\ngeo $arg_remote_addr $geo {\n    ...;\n}\n\n \n\n\n\n\nSince variables are evaluated only when used, the mere existence\nof even a large number of declared “geo” variables\ndoes not cause any extra costs for connection processing.\n\n \n\n\nIf the value of a variable does not represent a valid IP address\nthen the “255.255.255.255” address is used.\n\n\nAddresses are specified either as prefixes in CIDR notation\n(including individual addresses) or as ranges.\n\n\nThe following special parameters are also supported:\n\n\n\ndelete\n\ndeletes the specified network.\n\n\ndefault\n\na value set to the variable if the client address does not\nmatch any of the specified addresses.\nWhen addresses are specified in CIDR notation,\n“0.0.0.0/0” and “::/0”\ncan be used instead of default.\nWhen default is not specified, the default\nvalue will be an empty string.\n\n\ninclude\n\nincludes a file with addresses and values.\nThere can be several inclusions.\n\n\nranges\n\nindicates that addresses are specified as ranges.\nThis parameter should be the first.\nTo speed up loading of a geo base, addresses should be put in ascending order.\n\n\n\n \n\n\nExample:\n\ngeo $country {\n    default        ZZ;\n    include        conf/geo.conf;\n    delete         127.0.0.0/16;\n\n    127.0.0.0/24   US;\n    127.0.0.1/32   RU;\n    10.1.0.0/16    RU;\n    192.168.1.0/24 UK;\n}\n\n \n\n\nThe conf/geo.conf file could contain the following lines:\n\n10.2.0.0/16    RU;\n192.168.2.0/24 RU;\n\n \n\n\nA value of the most specific match is used.\nFor example, for the 127.0.0.1 address the value “RU”\nwill be chosen, not “US”.\n\n\nExample with ranges:\n\ngeo $country {\n    ranges;\n    default                   ZZ;\n    127.0.0.0-127.0.0.0       US;\n    127.0.0.1-127.0.0.1       RU;\n    127.0.0.1-127.0.0.255     US;\n    10.1.0.0-10.1.255.255     RU;\n    192.168.1.0-192.168.1.255 UK;\n}\n\n \n"
        }
      ]
    },
    {
      "name": "ngx_stream_geoip_module",
      "link": "https://nginx.org/en/docs/stream/ngx_stream_geoip_module.html",
      "directives": [
        {
          "name": "geoip_country",
          "syntax": "geoip_country file;",
          "context": "stream",
          "description": "\nSpecifies a database used to determine the country\ndepending on the client IP address.\nThe following variables are available when using this database:\n\n\n\n$geoip_country_code\n\ntwo-letter country code, for example,\n“RU”, “US”.\n\n\n$geoip_country_code3\n\n\nthree-letter country code, for example,\n“RUS”, “USA”.\n\n\n$geoip_country_name\n\ncountry name, for example,\n“Russian Federation”, “United States”.\n\n\n\n \n"
        },
        {
          "name": "geoip_city",
          "syntax": "geoip_city file;",
          "context": "stream",
          "description": "\nSpecifies a database used to determine the country, region, and city\ndepending on the client IP address.\nThe following variables are available when using this database:\n\n\n\n$geoip_area_code\ntelephone area code (US only).\n\nThis variable may contain outdated information since\nthe corresponding database field is deprecated.\n\n\n\n\n$geoip_city_continent_code\ntwo-letter continent code, for example,\n“EU”, “NA”.\n\n\n$geoip_city_country_code\n\n\ntwo-letter country code, for example,\n“RU”, “US”.\n\n\n$geoip_city_country_code3\n\n\nthree-letter country code, for example,\n“RUS”, “USA”.\n\n\n$geoip_city_country_name\n\n\ncountry name, for example,\n“Russian Federation”, “United States”.\n\n\n$geoip_dma_code\n\nDMA region code in US (also known as “metro code”), according to the\ngeotargeting\nin Google AdWords API.\n\n\n$geoip_latitude\nlatitude.\n\n$geoip_longitude\nlongitude.\n\n$geoip_region\n\ntwo-symbol country region code (region, territory, state, province, federal land\nand the like), for example,\n“48”, “DC”.\n\n\n$geoip_region_name\n\ncountry region name (region, territory, state, province, federal land\nand the like), for example,\n“Moscow City”, “District of Columbia”.\n\n\n$geoip_city\n\ncity name, for example,\n“Moscow”, “Washington”.\n\n\n$geoip_postal_code\n\npostal code.\n\n\n\n \n"
        },
        {
          "name": "geoip_org",
          "syntax": "geoip_org file;",
          "context": "stream",
          "description": "\nSpecifies a database used to determine the organization\ndepending on the client IP address.\nThe following variable is available when using this database:\n\n\n\n$geoip_org\n\norganization name, for example, “The University of Melbourne”.\n\n\n\n \n"
        }
      ]
    },
    {
      "name": "ngx_stream_keyval_module",
      "link": "https://nginx.org/en/docs/stream/ngx_stream_keyval_module.html",
      "directives": [
        {
          "name": "keyval",
          "syntax": "keyval key $variable zone=name;",
          "context": "stream",
          "description": "\nCreates a new $variable whose value\nis looked up by the key in the key-value database.\nStrings are matched ignoring the case.\nThe database is stored in a shared memory zone\nspecified by the zone parameter.\n"
        },
        {
          "name": "keyval_zone",
          "syntax": "keyval_zone zone=name:size [state=file] [timeout=time] [sync];",
          "context": "stream",
          "description": "\nSets the name and size of the shared memory zone\nthat keeps the key-value database.\nKey-value pairs are managed by the\nAPI.\n"
        }
      ]
    },
    {
      "name": "ngx_stream_limit_conn_module",
      "link": "https://nginx.org/en/docs/stream/ngx_stream_limit_conn_module.html",
      "directives": [
        {
          "name": "limit_conn",
          "syntax": "limit_conn zone number;",
          "context": "stream, server",
          "description": "\nSets the shared memory zone\nand the maximum allowed number of connections for a given key value.\nWhen this limit is exceeded, the server will close the connection.\nFor example, the directives\n\nlimit_conn_zone $binary_remote_addr zone=addr:10m;\n\nserver {\n    ...\n    limit_conn addr 1;\n}\n\n \nallow only one connection per an IP address at a time.\n\n\nWhen several limit_conn directives are specified,\nany configured limit will apply.\n\n\nThe directives are inherited from the previous level if and\nonly if there are no\nlimit_conn\ndirectives on the current level.\n"
        },
        {
          "name": "limit_conn_log_level",
          "syntax": "limit_conn_log_level info | notice | warn | error;",
          "default": "limit_conn_log_level error;",
          "context": "stream, server",
          "description": "\nSets the desired logging level for cases when the server\nlimits the number of connections.\n"
        },
        {
          "name": "limit_conn_zone",
          "syntax": "limit_conn_zone key zone=name:size;",
          "context": "stream",
          "description": "\nSets parameters for a shared memory zone\nthat will keep states for various keys.\nIn particular, the state includes the current number of connections.\nThe key can contain text, variables,\nand their combinations (1.11.2).\nConnections with an empty key value are not accounted.\nUsage example:\n\nlimit_conn_zone $binary_remote_addr zone=addr:10m;\n\n \nHere, the key is a client IP address set by the\n$binary_remote_addr variable.\nThe size of $binary_remote_addr\nis 4 bytes for IPv4 addresses or 16 bytes for IPv6 addresses.\nThe stored state always occupies 32 or 64 bytes\non 32-bit platforms and 64 bytes on 64-bit platforms.\nOne megabyte zone can keep about 32 thousand 32-byte states\nor about 16 thousand 64-byte states.\nIf the zone storage is exhausted, the server will close the connection.\n"
        }
      ]
    },
    {
      "name": "ngx_stream_log_module",
      "link": "https://nginx.org/en/docs/stream/ngx_stream_log_module.html",
      "directives": [
        {
          "name": "access_log",
          "syntax": "access_log path format [buffer=size] [gzip[=level]] [flush=time] [if=condition];access_log off;",
          "default": "access_log off;",
          "context": "stream, server",
          "description": "\nSets the path, format,\nand configuration for a buffered log write.\nSeveral logs can be specified on the same level.\nLogging to syslog\ncan be configured by specifying\nthe “syslog:” prefix in the first parameter.\nThe special value off cancels all\naccess_log directives on the current level.\n\n\nIf either the buffer or gzip\nparameter is used, writes to log will be buffered.\n\n\nThe buffer size must not exceed the size of an atomic write to a disk file.\nFor FreeBSD this size is unlimited.\n\n \n\n\nWhen buffering is enabled, the data will be written to the file:\n\n\n\n\nif the next log line does not fit into the buffer;\n\n\n\nif the buffered data is older than specified by the flush\nparameter;\n\n\n\nwhen a worker process is re-opening log\nfiles or is shutting down.\n\n\n\n \n\n\nIf the gzip parameter is used, then the buffered data will\nbe compressed before writing to the file.\nThe compression level can be set between 1 (fastest, less compression)\nand 9 (slowest, best compression).\nBy default, the buffer size is equal to 64K bytes, and the compression level\nis set to 1.\nSince the data is compressed in atomic blocks, the log file can be decompressed\nor read by “zcat” at any time.\n\n\nExample:\n\naccess_log /path/to/log.gz basic gzip flush=5m;\n\n \n\n\n\n\nFor gzip compression to work, nginx must be built with the zlib library.\n\n \n\n\nThe file path can contain variables,\nbut such logs have some constraints:\n\n\n\n\nthe user\nwhose credentials are used by worker processes should\nhave permissions to create files in a directory with\nsuch logs;\n\n\n\nbuffered writes do not work;\n\n\n\nthe file is opened and closed for each log write.\nHowever, since the descriptors of frequently used files can be stored\nin a cache, writing to the old file\ncan continue during the time specified by the open_log_file_cache\ndirective’s valid parameter\n\n\n\n \n\n\nThe if parameter enables conditional logging.\nA session will not be logged if the condition evaluates to “0”\nor an empty string.\n"
        },
        {
          "name": "log_format",
          "syntax": "log_format name [escape=default|json|none] string ...;",
          "context": "stream",
          "description": "\nSpecifies the log format, for example:\n\nlog_format proxy '$remote_addr [$time_local] '\n                 '$protocol $status $bytes_sent $bytes_received '\n                 '$session_time \"$upstream_addr\" '\n                 '\"$upstream_bytes_sent\" \"$upstream_bytes_received\" \"$upstream_connect_time\"';\n\n \n"
        },
        {
          "name": "open_log_file_cache",
          "syntax": "open_log_file_cache max=N [inactive=time] [min_uses=N] [valid=time];open_log_file_cache off;",
          "default": "open_log_file_cache off;",
          "context": "stream, server",
          "description": "\nDefines a cache that stores the file descriptors of frequently used logs\nwhose names contain variables.\nThe directive has the following parameters:\n\n\n\nmax\n\nsets the maximum number of descriptors in a cache;\nif the cache becomes full the least recently used (LRU)\ndescriptors are closed\n\n\ninactive\n\nsets the time after which the cached descriptor is closed\nif there were no access during this time;\nby default, 10 seconds\n\n\nmin_uses\n\nsets the minimum number of file uses during the time\ndefined by the inactive parameter\nto let the descriptor stay open in a cache;\nby default, 1\n\n\nvalid\n\nsets the time after which it should be checked that the file\nstill exists with the same name; by default, 60 seconds\n\n\noff\n\ndisables caching\n\n\n\n \n\n\nUsage example:\n\nopen_log_file_cache max=1000 inactive=20s valid=1m min_uses=2;\n\n \n"
        }
      ]
    },
    {
      "name": "ngx_stream_map_module",
      "link": "https://nginx.org/en/docs/stream/ngx_stream_map_module.html",
      "directives": [
        {
          "name": "map",
          "syntax": "map string $variable { ... }",
          "context": "stream",
          "description": "\nCreates a new variable whose value\ndepends on values of one or more of the source variables\nspecified in the first parameter.\n\n\n\n\nSince variables are evaluated only when they are used, the mere declaration\neven of a large number of “map” variables\ndoes not add any extra costs to connection processing.\n\n \n\n\nParameters inside the map block specify a mapping\nbetween source and resulting values.\n\n\nSource values are specified as strings or regular expressions.\n\n\nStrings are matched ignoring the case.\n\n\nA regular expression should either start from the “~”\nsymbol for a case-sensitive matching, or from the “~*”\nsymbols for case-insensitive matching.\nA regular expression can contain named and positional captures\nthat can later be used in other directives along with the\nresulting variable.\n\n\nIf a source value matches one of the names of special parameters\ndescribed below, it should be prefixed with the “\\” symbol.\n\n\nThe resulting value can contain text,\nvariable, and their combination.\n\n\nThe following special parameters are also supported:\n\n\ndefault value\n\nsets the resulting value if the source value matches none\nof the specified variants.\nWhen default is not specified, the default\nresulting value will be an empty string.\n\n\nhostnames\n\nindicates that source values can be hostnames with a prefix or suffix mask:\n*.example.com 1;\nexample.*     1;\n\nThe following two records\nexample.com   1;\n*.example.com 1;\n\ncan be combined:\n.example.com  1;\n\nThis parameter should be specified before the list of values.\n\n\ninclude file\n\nincludes a file with values.\nThere can be several inclusions.\n\n\nvolatile\n\nindicates that the variable is not cacheable (1.11.7).\n\n\n\n \n\n\nIf the source value matches more than one of the specified variants,\ne.g. both a mask and a regular expression match, the first matching\nvariant will be chosen, in the following order of priority:\n\n\n\n\nstring value without a mask\n\n\n\nlongest string value with a prefix mask,\ne.g. “*.example.com”\n\n\n\nlongest string value with a suffix mask,\ne.g. “mail.*”\n\n\n\nfirst matching regular expression\n(in order of appearance in a configuration file)\n\n\n\ndefault value\n\n\n\n \n"
        },
        {
          "name": "map_hash_bucket_size",
          "syntax": "map_hash_bucket_size size;",
          "default": "map_hash_bucket_size 32|64|128;",
          "context": "stream",
          "description": "\nSets the bucket size for the map variables hash tables.\nDefault value depends on the processor’s cache line size.\nThe details of setting up hash tables are provided in a separate\ndocument.\n"
        },
        {
          "name": "map_hash_max_size",
          "syntax": "map_hash_max_size size;",
          "default": "map_hash_max_size 2048;",
          "context": "stream",
          "description": "\nSets the maximum size of the map variables\nhash tables.\nThe details of setting up hash tables are provided in a separate\ndocument.\n"
        }
      ]
    },
    {
      "name": "ngx_stream_proxy_module",
      "link": "https://nginx.org/en/docs/stream/ngx_stream_proxy_module.html",
      "directives": [
        {
          "name": "proxy_bind",
          "syntax": "proxy_bind address [transparent] | off;",
          "context": "stream, server",
          "description": "\nMakes outgoing connections to a proxied server originate\nfrom the specified local IP address.\nParameter value can contain variables (1.11.2).\nThe special value off cancels the effect\nof the proxy_bind directive\ninherited from the previous configuration level, which allows the\nsystem to auto-assign the local IP address.\n"
        },
        {
          "name": "proxy_buffer_size",
          "syntax": "proxy_buffer_size size;",
          "default": "proxy_buffer_size 16k;",
          "context": "stream, server",
          "description": "\nSets the size of the buffer used for reading data\nfrom the proxied server.\nAlso sets the size of the buffer used for reading data\nfrom the client.\n"
        },
        {
          "name": "proxy_connect_timeout",
          "syntax": "proxy_connect_timeout time;",
          "default": "proxy_connect_timeout 60s;",
          "context": "stream, server",
          "description": "\nDefines a timeout for establishing a connection with a proxied server.\n"
        },
        {
          "name": "proxy_download_rate",
          "syntax": "proxy_download_rate rate;",
          "default": "proxy_download_rate 0;",
          "context": "stream, server",
          "description": "\nLimits the speed of reading the data from the proxied server.\nThe rate is specified in bytes per second.\nThe zero value disables rate limiting.\nThe limit is set per a connection, so if nginx simultaneously opens\ntwo connections to the proxied server,\nthe overall rate will be twice as much as the specified limit.\n\n\nParameter value can contain variables (1.17.0).\nIt may be useful in cases where rate should be limited\ndepending on a certain condition:\n\nmap $slow $rate {\n    1     4k;\n    2     8k;\n}\n\nproxy_download_rate $rate;\n\n \n"
        },
        {
          "name": "proxy_next_upstream",
          "syntax": "proxy_next_upstream on | off;",
          "default": "proxy_next_upstream on;",
          "context": "stream, server",
          "description": "\nWhen a connection to the proxied server cannot be established, determines\nwhether a client connection will be passed to the next server.\n\n\nPassing a connection to the next server can be limited by\nthe number of tries\nand by time.\n"
        },
        {
          "name": "proxy_next_upstream_timeout",
          "syntax": "proxy_next_upstream_timeout time;",
          "default": "proxy_next_upstream_timeout 0;",
          "context": "stream, server",
          "description": "\nLimits the time allowed to pass a connection to the\nnext server.\nThe 0 value turns off this limitation.\n"
        },
        {
          "name": "proxy_next_upstream_tries",
          "syntax": "proxy_next_upstream_tries number;",
          "default": "proxy_next_upstream_tries 0;",
          "context": "stream, server",
          "description": "\nLimits the number of possible tries for passing a connection to the\nnext server.\nThe 0 value turns off this limitation.\n"
        },
        {
          "name": "proxy_pass",
          "syntax": "proxy_pass address;",
          "context": "server",
          "description": "\nSets the address of a proxied server.\nThe address can be specified as a domain name or IP address,\nand a port:\n\nproxy_pass localhost:12345;\n\n \nor as a UNIX-domain socket path:\n\nproxy_pass unix:/tmp/stream.socket;\n\n \n\n\nIf a domain name resolves to several addresses, all of them will be\nused in a round-robin fashion.\nIn addition, an address can be specified as a\nserver group.\n\n\nThe address can also be specified using variables (1.11.3):\n\nproxy_pass $upstream;\n\n \nIn this case, the server name is searched among the described\nserver groups,\nand, if not found, is determined using a\nresolver.\n"
        },
        {
          "name": "proxy_protocol",
          "syntax": "proxy_protocol on | off;",
          "default": "proxy_protocol off;",
          "context": "stream, server",
          "description": "\nEnables the\nPROXY\nprotocol for connections to a proxied server.\n"
        },
        {
          "name": "proxy_requests",
          "syntax": "proxy_requests number;",
          "default": "proxy_requests 0;",
          "context": "stream, server",
          "description": "\nSets the number of client datagrams at which\nbinding between a client and existing UDP stream session is dropped.\nAfter receiving the specified number of datagrams, next datagram\nfrom the same client starts a new session.\nThe session terminates when all client datagrams are transmitted\nto a proxied server and the expected number of\nresponses is received,\nor when it reaches a timeout.\n"
        },
        {
          "name": "proxy_responses",
          "syntax": "proxy_responses number;",
          "context": "stream, server",
          "description": "\nSets the number of datagrams expected from the proxied server\nin response to a client datagram\nif the UDP\nprotocol is used.\nThe number serves as a hint for session termination.\nBy default, the number of datagrams is not limited.\n\n\nIf zero value is specified, no response is expected.\nHowever, if a response is received and the\nsession is still not finished, the response will be handled.\n"
        },
        {
          "name": "proxy_socket_keepalive",
          "syntax": "proxy_socket_keepalive on | off;",
          "default": "proxy_socket_keepalive off;",
          "context": "stream, server",
          "description": "\nConfigures the “TCP keepalive” behavior\nfor outgoing connections to a proxied server.\nBy default, the operating system’s settings are in effect for the socket.\nIf the directive is set to the value “on”, the\nSO_KEEPALIVE socket option is turned on for the socket.\n"
        },
        {
          "name": "proxy_ssl",
          "syntax": "proxy_ssl on | off;",
          "default": "proxy_ssl off;",
          "context": "stream, server",
          "description": "\nEnables the SSL/TLS protocol for connections to a proxied server.\n"
        },
        {
          "name": "proxy_ssl_certificate",
          "syntax": "proxy_ssl_certificate file;",
          "context": "stream, server",
          "description": "\nSpecifies a file with the certificate in the PEM format\nused for authentication to a proxied server.\n"
        },
        {
          "name": "proxy_ssl_certificate_key",
          "syntax": "proxy_ssl_certificate_key file;",
          "context": "stream, server",
          "description": "\nSpecifies a file with the secret key in the PEM format\nused for authentication to a proxied server.\n"
        },
        {
          "name": "proxy_ssl_ciphers",
          "syntax": "proxy_ssl_ciphers ciphers;",
          "default": "proxy_ssl_ciphers DEFAULT;",
          "context": "stream, server",
          "description": "\nSpecifies the enabled ciphers for connections to a proxied server.\nThe ciphers are specified in the format understood by the OpenSSL library.\n\n\nThe full list can be viewed using the\n“openssl ciphers” command.\n"
        },
        {
          "name": "proxy_ssl_crl",
          "syntax": "proxy_ssl_crl file;",
          "context": "stream, server",
          "description": "\nSpecifies a file with revoked certificates (CRL)\nin the PEM format used to verify\nthe certificate of the proxied server.\n"
        },
        {
          "name": "proxy_ssl_name",
          "syntax": "proxy_ssl_name name;",
          "default": "proxy_ssl_name host from proxy_pass;",
          "context": "stream, server",
          "description": "\nAllows overriding the server name used to\nverify\nthe certificate of the proxied server and to be\npassed through SNI\nwhen establishing a connection with the proxied server.\nThe server name can also be specified using variables (1.11.3).\n\n\nBy default, the host part of the proxy_pass address is used.\n"
        },
        {
          "name": "proxy_ssl_password_file",
          "syntax": "proxy_ssl_password_file file;",
          "context": "stream, server",
          "description": "\nSpecifies a file with passphrases for\nsecret keys\nwhere each passphrase is specified on a separate line.\nPassphrases are tried in turn when loading the key.\n"
        },
        {
          "name": "proxy_ssl_protocols",
          "syntax": "proxy_ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2] [TLSv1.3];",
          "default": "proxy_ssl_protocols TLSv1 TLSv1.1 TLSv1.2;",
          "context": "stream, server",
          "description": "\nEnables the specified protocols for connections to a proxied server.\n"
        },
        {
          "name": "proxy_ssl_server_name",
          "syntax": "proxy_ssl_server_name on | off;",
          "default": "proxy_ssl_server_name off;",
          "context": "stream, server",
          "description": "\nEnables or disables passing of the server name through\nTLS\nServer Name Indication extension (SNI, RFC 6066)\nwhen establishing a connection with the proxied server.\n"
        },
        {
          "name": "proxy_ssl_session_reuse",
          "syntax": "proxy_ssl_session_reuse on | off;",
          "default": "proxy_ssl_session_reuse on;",
          "context": "stream, server",
          "description": "\nDetermines whether SSL sessions can be reused when working with\nthe proxied server.\nIf the errors\n“SSL3_GET_FINISHED:digest check failed”\nappear in the logs, try disabling session reuse.\n"
        },
        {
          "name": "proxy_ssl_trusted_certificate",
          "syntax": "proxy_ssl_trusted_certificate file;",
          "context": "stream, server",
          "description": "\nSpecifies a file with trusted CA certificates in the PEM format\nused to verify\nthe certificate of the proxied server.\n"
        },
        {
          "name": "proxy_ssl_verify",
          "syntax": "proxy_ssl_verify on | off;",
          "default": "proxy_ssl_verify off;",
          "context": "stream, server",
          "description": "\nEnables or disables verification of the proxied server certificate.\n"
        },
        {
          "name": "proxy_ssl_verify_depth",
          "syntax": "proxy_ssl_verify_depth number;",
          "default": "proxy_ssl_verify_depth 1;",
          "context": "stream, server",
          "description": "\nSets the verification depth in the proxied server certificates chain.\n"
        },
        {
          "name": "proxy_timeout",
          "syntax": "proxy_timeout timeout;",
          "default": "proxy_timeout 10m;",
          "context": "stream, server",
          "description": "\nSets the timeout between two successive\nread or write operations on client or proxied server connections.\nIf no data is transmitted within this time, the connection is closed.\n"
        },
        {
          "name": "proxy_upload_rate",
          "syntax": "proxy_upload_rate rate;",
          "default": "proxy_upload_rate 0;",
          "context": "stream, server",
          "description": "\nLimits the speed of reading the data from the client.\nThe rate is specified in bytes per second.\nThe zero value disables rate limiting.\nThe limit is set per a connection, so if the client simultaneously opens\ntwo connections,\nthe overall rate will be twice as much as the specified limit.\n\n\nParameter value can contain variables (1.17.0).\nIt may be useful in cases where rate should be limited\ndepending on a certain condition:\n\nmap $slow $rate {\n    1     4k;\n    2     8k;\n}\n\nproxy_upload_rate $rate;\n\n \n"
        }
      ]
    },
    {
      "name": "ngx_stream_realip_module",
      "link": "https://nginx.org/en/docs/stream/ngx_stream_realip_module.html",
      "directives": [
        {
          "name": "set_real_ip_from",
          "syntax": "set_real_ip_from address | CIDR | unix:;",
          "context": "stream, server",
          "description": "\nDefines trusted addresses that are known to send correct\nreplacement addresses.\nIf the special value unix: is specified,\nall UNIX-domain sockets will be trusted.\n"
        }
      ]
    },
    {
      "name": "ngx_stream_return_module",
      "link": "https://nginx.org/en/docs/stream/ngx_stream_return_module.html",
      "directives": [
        {
          "name": "return",
          "syntax": "return value;",
          "context": "server",
          "description": "\nSpecifies a value to send to the client.\nThe value can contain text, variables, and their combination.\n"
        }
      ]
    },
    {
      "name": "ngx_stream_split_clients_module",
      "link": "https://nginx.org/en/docs/stream/ngx_stream_split_clients_module.html",
      "directives": [
        {
          "name": "split_clients",
          "syntax": "split_clients string $variable { ... }",
          "context": "stream",
          "description": "\nCreates a variable for A/B testing, for example:\n\nsplit_clients \"${remote_addr}AAA\" $variant {\n               0.5%               .one;\n               2.0%               .two;\n               *                  \"\";\n}\n\n \nThe value of the original string is hashed using MurmurHash2.\nIn the example given, hash values from 0 to 21474835 (0.5%)\ncorrespond to the\nvalue \".one\" of the $variant variable,\nhash values from 21474836 to 107374180 (2%) correspond to\nthe value \".two\",\nand hash values from 107374181 to 4294967295 correspond to\nthe value \"\" (an empty string).\n"
        }
      ]
    },
    {
      "name": "ngx_stream_ssl_module",
      "link": "https://nginx.org/en/docs/stream/ngx_stream_ssl_module.html",
      "directives": [
        {
          "name": "ssl_certificate",
          "syntax": "ssl_certificate file;",
          "context": "stream, server",
          "description": "\nSpecifies a file with the certificate in the PEM format\nfor the given server.\nIf intermediate certificates should be specified in addition to a primary\ncertificate, they should be specified in the same file in the following\norder: the primary certificate comes first, then the intermediate certificates.\nA secret key in the PEM format may be placed in the same file.\n\n\nSince version 1.11.0,\nthis directive can be specified multiple times\nto load certificates of different types, for example, RSA and ECDSA:\n\nserver {\n    listen              12345 ssl;\n\n    ssl_certificate     example.com.rsa.crt;\n    ssl_certificate_key example.com.rsa.key;\n\n    ssl_certificate     example.com.ecdsa.crt;\n    ssl_certificate_key example.com.ecdsa.key;\n\n    ...\n}\n\n \n\n\nOnly OpenSSL 1.0.2 or higher supports separate certificate chains\nfor different certificates.\nWith older versions, only one certificate chain can be used.\n\n \n\n\nSince version 1.15.9, variables can be used in the file name\nwhen using OpenSSL 1.0.2 or higher:\n\nssl_certificate     $ssl_server_name.crt;\nssl_certificate_key $ssl_server_name.key;\n\n \nNote that using variables implies that\na certificate will be loaded for each SSL handshake,\nand this may have a negative impact on performance.\n"
        },
        {
          "name": "ssl_certificate_key",
          "syntax": "ssl_certificate_key file;",
          "context": "stream, server",
          "description": "\nSpecifies a file with the secret key in the PEM format\nfor the given server.\n\n\nThe value\nengine:name:id\ncan be specified instead of the file,\nwhich loads a secret key with a specified id\nfrom the OpenSSL engine name.\n"
        },
        {
          "name": "ssl_ciphers",
          "syntax": "ssl_ciphers ciphers;",
          "default": "ssl_ciphers HIGH:!aNULL:!MD5;",
          "context": "stream, server",
          "description": "\nSpecifies the enabled ciphers.\nThe ciphers are specified in the format understood by the\nOpenSSL library, for example:\n\nssl_ciphers ALL:!aNULL:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;\n\n \n\n\nThe full list can be viewed using the\n“openssl ciphers” command.\n"
        },
        {
          "name": "ssl_client_certificate",
          "syntax": "ssl_client_certificate file;",
          "context": "stream, server",
          "description": "\nSpecifies a file with trusted CA certificates in the PEM format\nused to verify client certificates.\n\n\nThe list of certificates will be sent to clients.\nIf this is not desired, the ssl_trusted_certificate\ndirective can be used.\n"
        },
        {
          "name": "ssl_crl",
          "syntax": "ssl_crl file;",
          "context": "stream, server",
          "description": "\nSpecifies a file with revoked certificates (CRL)\nin the PEM format used to verify\nclient certificates.\n"
        },
        {
          "name": "ssl_dhparam",
          "syntax": "ssl_dhparam file;",
          "context": "stream, server",
          "description": "\nSpecifies a file with DH parameters for DHE ciphers.\n\n\nBy default no parameters are set,\nand therefore DHE ciphers will not be used.\n\n\nPrior to version 1.11.0, builtin parameters were used by default.\n\n \n"
        },
        {
          "name": "ssl_ecdh_curve",
          "syntax": "ssl_ecdh_curve curve;",
          "default": "ssl_ecdh_curve auto;",
          "context": "stream, server",
          "description": "\nSpecifies a curve for ECDHE ciphers.\n\n\nWhen using OpenSSL 1.0.2 or higher,\nit is possible to specify multiple curves (1.11.0), for example:\n\nssl_ecdh_curve prime256v1:secp384r1;\n\n \n\n\nThe special value auto (1.11.0) instructs nginx to use\na list built into the OpenSSL library when using OpenSSL 1.0.2 or higher,\nor prime256v1 with older versions.\n\n\n\n\nPrior to version 1.11.0,\nthe prime256v1 curve was used by default.\n\n \n"
        },
        {
          "name": "ssl_handshake_timeout",
          "syntax": "ssl_handshake_timeout time;",
          "default": "ssl_handshake_timeout 60s;",
          "context": "stream, server",
          "description": "\nSpecifies a timeout for the SSL handshake to complete.\n"
        },
        {
          "name": "ssl_password_file",
          "syntax": "ssl_password_file file;",
          "context": "stream, server",
          "description": "\nSpecifies a file with passphrases for\nsecret keys\nwhere each passphrase is specified on a separate line.\nPassphrases are tried in turn when loading the key.\n\n\nExample:\n\nstream {\n    ssl_password_file /etc/keys/global.pass;\n    ...\n\n    server {\n        listen 127.0.0.1:12345;\n        ssl_certificate_key /etc/keys/first.key;\n    }\n\n    server {\n        listen 127.0.0.1:12346;\n\n        # named pipe can also be used instead of a file\n        ssl_password_file /etc/keys/fifo;\n        ssl_certificate_key /etc/keys/second.key;\n    }\n}\n\n \n"
        },
        {
          "name": "ssl_prefer_server_ciphers",
          "syntax": "ssl_prefer_server_ciphers on | off;",
          "default": "ssl_prefer_server_ciphers off;",
          "context": "stream, server",
          "description": "\nSpecifies that server ciphers should be preferred over client ciphers\nwhen the SSLv3 and TLS protocols are used.\n"
        },
        {
          "name": "ssl_protocols",
          "syntax": "ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2] [TLSv1.3];",
          "default": "ssl_protocols TLSv1 TLSv1.1 TLSv1.2;",
          "context": "stream, server",
          "description": "\nEnables the specified protocols.\n\n\nThe TLSv1.1 and TLSv1.2 parameters work\nonly when OpenSSL 1.0.1 or higher is used.\n\n \n\n\nThe TLSv1.3 parameter (1.13.0) works only when\nOpenSSL 1.1.1 built with TLSv1.3 support is used.\n\n \n"
        },
        {
          "name": "ssl_session_cache",
          "syntax": "ssl_session_cache off | none | [builtin[:size]] [shared:name:size];",
          "default": "ssl_session_cache none;",
          "context": "stream, server",
          "description": "\nSets the types and sizes of caches that store session parameters.\nA cache can be of any of the following types:\n\n\n\noff\n\nthe use of a session cache is strictly prohibited:\nnginx explicitly tells a client that sessions may not be reused.\n\n\nnone\n\nthe use of a session cache is gently disallowed:\nnginx tells a client that sessions may be reused, but does not\nactually store session parameters in the cache.\n\n\nbuiltin\n\na cache built in OpenSSL; used by one worker process only.\nThe cache size is specified in sessions.\nIf size is not given, it is equal to 20480 sessions.\nUse of the built-in cache can cause memory fragmentation.\n\n\nshared\n\na cache shared between all worker processes.\nThe cache size is specified in bytes; one megabyte can store\nabout 4000 sessions.\nEach shared cache should have an arbitrary name.\nA cache with the same name can be used in several\nservers.\n\n\n\n \n\n\nBoth cache types can be used simultaneously, for example:\n\nssl_session_cache builtin:1000 shared:SSL:10m;\n\n \nbut using only shared cache without the built-in cache should\nbe more efficient.\n"
        },
        {
          "name": "ssl_session_ticket_key",
          "syntax": "ssl_session_ticket_key file;",
          "context": "stream, server",
          "description": "\nSets a file with the secret key used to encrypt\nand decrypt TLS session tickets.\nThe directive is necessary if the same key has to be shared between\nmultiple servers.\nBy default, a randomly generated key is used.\n\n\nIf several keys are specified, only the first key is\nused to encrypt TLS session tickets.\nThis allows configuring key rotation, for example:\n\nssl_session_ticket_key current.key;\nssl_session_ticket_key previous.key;\n\n \n\n\nThe file must contain 80 or 48 bytes\nof random data and can be created using the following command:\n\nopenssl rand 80 > ticket.key\n\n \nDepending on the file size either AES256 (for 80-byte keys, 1.11.8)\nor AES128 (for 48-byte keys) is used for encryption.\n"
        },
        {
          "name": "ssl_session_tickets",
          "syntax": "ssl_session_tickets on | off;",
          "default": "ssl_session_tickets on;",
          "context": "stream, server",
          "description": "\nEnables or disables session resumption through\nTLS session tickets.\n"
        },
        {
          "name": "ssl_session_timeout",
          "syntax": "ssl_session_timeout time;",
          "default": "ssl_session_timeout 5m;",
          "context": "stream, server",
          "description": "\nSpecifies a time during which a client may reuse the\nsession parameters.\n"
        },
        {
          "name": "ssl_trusted_certificate",
          "syntax": "ssl_trusted_certificate file;",
          "context": "stream, server",
          "description": "\nSpecifies a file with trusted CA certificates in the PEM format\nused to verify client certificates.\n\n\nIn contrast to the certificate set by ssl_client_certificate,\nthe list of these certificates will not be sent to clients.\n"
        },
        {
          "name": "ssl_verify_client",
          "syntax": "ssl_verify_client on | off | optional | optional_no_ca;",
          "default": "ssl_verify_client off;",
          "context": "stream, server",
          "description": "\nEnables verification of client certificates.\nThe verification result is stored in the\n$ssl_client_verify variable.\nIf an error has occurred during the client certificate verification\nor a client has not presented the required certificate,\nthe connection is closed.\n\n\nThe optional parameter requests the client\ncertificate and verifies it if the certificate is present.\n\n\nThe optional_no_ca parameter\nrequests the client\ncertificate but does not require it to be signed by a trusted CA certificate.\nThis is intended for the use in cases when a service that is external to nginx\nperforms the actual certificate verification.\nThe contents of the certificate is accessible through the\n$ssl_client_cert variable.\n"
        },
        {
          "name": "ssl_verify_depth",
          "syntax": "ssl_verify_depth number;",
          "default": "ssl_verify_depth 1;",
          "context": "stream, server",
          "description": "\nSets the verification depth in the client certificates chain.\n"
        }
      ]
    },
    {
      "name": "ngx_stream_ssl_preread_module",
      "link": "https://nginx.org/en/docs/stream/ngx_stream_ssl_preread_module.html",
      "directives": [
        {
          "name": "ssl_preread",
          "syntax": "ssl_preread on | off;",
          "default": "ssl_preread off;",
          "context": "stream, server",
          "description": "\nEnables extracting information from the ClientHello message at\nthe preread phase.\n"
        }
      ]
    }
  ]
}